{"version":3,"file":"5996-91ff5513cfaae7cf3fb2.js","mappings":"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","sources":["webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/resources.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/mime.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/registry/common/platform.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/extpath.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/glob.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as extpath from './extpath.js';\nimport { Schemas } from './network.js';\nimport * as paths from './path.js';\nimport { isLinux, isWindows } from './platform.js';\nimport { compare as strCompare, equalsIgnoreCase } from './strings.js';\nimport { URI, uriToFsPath } from './uri.js';\nexport function originalFSPath(uri) {\n    return uriToFsPath(uri, true);\n}\nexport class ExtUri {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n    }\n    compare(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return 0;\n        }\n        return strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n    isEqual(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return true;\n        }\n        if (!uri1 || !uri2) {\n            return false;\n        }\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n    getComparisonKey(uri, ignoreFragment = false) {\n        return uri.with({\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n            fragment: ignoreFragment ? null : undefined\n        }).toString();\n    }\n    isEqualOrParent(base, parentCandidate, ignoreFragment = false) {\n        if (base.scheme === parentCandidate.scheme) {\n            if (base.scheme === Schemas.file) {\n                return extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n            if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n                return extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n        }\n        return false;\n    }\n    // --- path math\n    joinPath(resource, ...pathFragment) {\n        return URI.joinPath(resource, ...pathFragment);\n    }\n    basenameOrAuthority(resource) {\n        return basename(resource) || resource.authority;\n    }\n    basename(resource) {\n        return paths.posix.basename(resource.path);\n    }\n    extname(resource) {\n        return paths.posix.extname(resource.path);\n    }\n    dirname(resource) {\n        if (resource.path.length === 0) {\n            return resource;\n        }\n        let dirname;\n        if (resource.scheme === Schemas.file) {\n            dirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n        }\n        else {\n            dirname = paths.posix.dirname(resource.path);\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 /* CharCode.Slash */) {\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n                dirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n            }\n        }\n        return resource.with({\n            path: dirname\n        });\n    }\n    normalizePath(resource) {\n        if (!resource.path.length) {\n            return resource;\n        }\n        let normalizedPath;\n        if (resource.scheme === Schemas.file) {\n            normalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n        }\n        else {\n            normalizedPath = paths.posix.normalize(resource.path);\n        }\n        return resource.with({\n            path: normalizedPath\n        });\n    }\n    relativePath(from, to) {\n        if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n            return undefined;\n        }\n        if (from.scheme === Schemas.file) {\n            const relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n            return isWindows ? extpath.toSlashes(relativePath) : relativePath;\n        }\n        let fromPath = from.path || '/';\n        const toPath = to.path || '/';\n        if (this._ignorePathCasing(from)) {\n            // make casing of fromPath match toPath\n            let i = 0;\n            for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n                if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n                    if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n                        break;\n                    }\n                }\n            }\n            fromPath = toPath.substr(0, i) + fromPath.substr(i);\n        }\n        return paths.posix.relative(fromPath, toPath);\n    }\n    resolvePath(base, path) {\n        if (base.scheme === Schemas.file) {\n            const newURI = URI.file(paths.resolve(originalFSPath(base), path));\n            return base.with({\n                authority: newURI.authority,\n                path: newURI.path\n            });\n        }\n        path = extpath.toPosixPath(path); // we allow path to be a windows path\n        return base.with({\n            path: paths.posix.resolve(base.path, path)\n        });\n    }\n    // --- misc\n    isAbsolutePath(resource) {\n        return !!resource.path && resource.path[0] === '/';\n    }\n    isEqualAuthority(a1, a2) {\n        return a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n    }\n    hasTrailingPathSeparator(resource, sep = paths.sep) {\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            return fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n        }\n        else {\n            const p = resource.path;\n            return (p.length > 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n        }\n    }\n    removeTrailingPathSeparator(resource, sep = paths.sep) {\n        // Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n        if (hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n        }\n        return resource;\n    }\n    addTrailingPathSeparator(resource, sep = paths.sep) {\n        let isRootSep = false;\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            isRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n        }\n        else {\n            sep = '/';\n            const p = resource.path;\n            isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 /* CharCode.Slash */;\n        }\n        if (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n            return resource.with({ path: resource.path + '/' });\n        }\n        return resource;\n    }\n}\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n    // A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n    // Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n    return uri.scheme === Schemas.file ? !isLinux : true;\n});\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n/**\n * Data URI related helpers.\n */\nexport var DataUri;\n(function (DataUri) {\n    DataUri.META_DATA_LABEL = 'label';\n    DataUri.META_DATA_DESCRIPTION = 'description';\n    DataUri.META_DATA_SIZE = 'size';\n    DataUri.META_DATA_MIME = 'mime';\n    function parseMetaData(dataUri) {\n        const metadata = new Map();\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n        meta.split(';').forEach(property => {\n            const [key, value] = property.split(':');\n            if (key && value) {\n                metadata.set(key, value);\n            }\n        });\n        // Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n        // the mime is: image/png\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n        if (mime) {\n            metadata.set(DataUri.META_DATA_MIME, mime);\n        }\n        return metadata;\n    }\n    DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../base/common/arrays.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport * as types from '../../../base/common/types.js';\nimport * as nls from '../../../nls.js';\nimport { getLanguageTagSettingPlainKey } from './configuration.js';\nimport { Extensions as JSONExtensions } from '../../jsonschemas/common/jsonContributionRegistry.js';\nimport { Registry } from '../../registry/common/platform.js';\nexport const Extensions = {\n    Configuration: 'base.contributions.configuration'\n};\nexport const allSettings = { properties: {}, patternProperties: {} };\nexport const applicationSettings = { properties: {}, patternProperties: {} };\nexport const machineSettings = { properties: {}, patternProperties: {} };\nexport const machineOverridableSettings = { properties: {}, patternProperties: {} };\nexport const windowSettings = { properties: {}, patternProperties: {} };\nexport const resourceSettings = { properties: {}, patternProperties: {} };\nexport const resourceLanguageSettingsSchemaId = 'vscode://schemas/settings/resourceLanguage';\nconst contributionRegistry = Registry.as(JSONExtensions.JSONContribution);\nclass ConfigurationRegistry {\n    constructor() {\n        this.registeredConfigurationDefaults = [];\n        this.overrideIdentifiers = new Set();\n        this._onDidSchemaChange = new Emitter();\n        this._onDidUpdateConfiguration = new Emitter();\n        this.configurationDefaultsOverrides = new Map();\n        this.defaultLanguageConfigurationOverridesNode = {\n            id: 'defaultOverrides',\n            title: nls.localize('defaultLanguageConfigurationOverrides.title', \"Default Language Configuration Overrides\"),\n            properties: {}\n        };\n        this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode];\n        this.resourceLanguageSettingsSchema = {\n            properties: {},\n            patternProperties: {},\n            additionalProperties: true,\n            allowTrailingCommas: true,\n            allowComments: true\n        };\n        this.configurationProperties = {};\n        this.policyConfigurations = new Map();\n        this.excludedConfigurationProperties = {};\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n        this.registerOverridePropertyPatternKey();\n    }\n    registerConfiguration(configuration, validate = true) {\n        this.registerConfigurations([configuration], validate);\n    }\n    registerConfigurations(configurations, validate = true) {\n        const properties = new Set();\n        this.doRegisterConfigurations(configurations, validate, properties);\n        contributionRegistry.registerSchema(resourceLanguageSettingsSchemaId, this.resourceLanguageSettingsSchema);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties });\n    }\n    registerDefaultConfigurations(configurationDefaults) {\n        const properties = new Set();\n        this.doRegisterDefaultConfigurations(configurationDefaults, properties);\n        this._onDidSchemaChange.fire();\n        this._onDidUpdateConfiguration.fire({ properties, defaultsOverrides: true });\n    }\n    doRegisterDefaultConfigurations(configurationDefaults, bucket) {\n        this.registeredConfigurationDefaults.push(...configurationDefaults);\n        const overrideIdentifiers = [];\n        for (const { overrides, source } of configurationDefaults) {\n            for (const key in overrides) {\n                bucket.add(key);\n                const configurationDefaultOverridesForKey = this.configurationDefaultsOverrides.get(key)\n                    ?? this.configurationDefaultsOverrides.set(key, { configurationDefaultOverrides: [] }).get(key);\n                const value = overrides[key];\n                configurationDefaultOverridesForKey.configurationDefaultOverrides.push({ value, source });\n                // Configuration defaults for Override Identifiers\n                if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n                    const newDefaultOverride = this.mergeDefaultConfigurationsForOverrideIdentifier(key, value, source, configurationDefaultOverridesForKey.configurationDefaultOverrideValue);\n                    if (!newDefaultOverride) {\n                        continue;\n                    }\n                    configurationDefaultOverridesForKey.configurationDefaultOverrideValue = newDefaultOverride;\n                    this.updateDefaultOverrideProperty(key, newDefaultOverride, source);\n                    overrideIdentifiers.push(...overrideIdentifiersFromKey(key));\n                }\n                // Configuration defaults for Configuration Properties\n                else {\n                    const newDefaultOverride = this.mergeDefaultConfigurationsForConfigurationProperty(key, value, source, configurationDefaultOverridesForKey.configurationDefaultOverrideValue);\n                    if (!newDefaultOverride) {\n                        continue;\n                    }\n                    configurationDefaultOverridesForKey.configurationDefaultOverrideValue = newDefaultOverride;\n                    const property = this.configurationProperties[key];\n                    if (property) {\n                        this.updatePropertyDefaultValue(key, property);\n                        this.updateSchema(key, property);\n                    }\n                }\n            }\n        }\n        this.doRegisterOverrideIdentifiers(overrideIdentifiers);\n    }\n    updateDefaultOverrideProperty(key, newDefaultOverride, source) {\n        const property = {\n            type: 'object',\n            default: newDefaultOverride.value,\n            description: nls.localize('defaultLanguageConfiguration.description', \"Configure settings to be overridden for the {0} language.\", getLanguageTagSettingPlainKey(key)),\n            $ref: resourceLanguageSettingsSchemaId,\n            defaultDefaultValue: newDefaultOverride.value,\n            source,\n            defaultValueSource: source\n        };\n        this.configurationProperties[key] = property;\n        this.defaultLanguageConfigurationOverridesNode.properties[key] = property;\n    }\n    mergeDefaultConfigurationsForOverrideIdentifier(overrideIdentifier, configurationValueObject, valueSource, existingDefaultOverride) {\n        const defaultValue = existingDefaultOverride?.value || {};\n        const source = existingDefaultOverride?.source ?? new Map();\n        // This should not happen\n        if (!(source instanceof Map)) {\n            console.error('objectConfigurationSources is not a Map');\n            return undefined;\n        }\n        for (const propertyKey of Object.keys(configurationValueObject)) {\n            const propertyDefaultValue = configurationValueObject[propertyKey];\n            const isObjectSetting = types.isObject(propertyDefaultValue) &&\n                (types.isUndefined(defaultValue[propertyKey]) || types.isObject(defaultValue[propertyKey]));\n            // If the default value is an object, merge the objects and store the source of each keys\n            if (isObjectSetting) {\n                defaultValue[propertyKey] = { ...(defaultValue[propertyKey] ?? {}), ...propertyDefaultValue };\n                // Track the source of each value in the object\n                if (valueSource) {\n                    for (const objectKey in propertyDefaultValue) {\n                        source.set(`${propertyKey}.${objectKey}`, valueSource);\n                    }\n                }\n            }\n            // Primitive values are overridden\n            else {\n                defaultValue[propertyKey] = propertyDefaultValue;\n                if (valueSource) {\n                    source.set(propertyKey, valueSource);\n                }\n                else {\n                    source.delete(propertyKey);\n                }\n            }\n        }\n        return { value: defaultValue, source };\n    }\n    mergeDefaultConfigurationsForConfigurationProperty(propertyKey, value, valuesSource, existingDefaultOverride) {\n        const property = this.configurationProperties[propertyKey];\n        const existingDefaultValue = existingDefaultOverride?.value ?? property?.defaultDefaultValue;\n        let source = valuesSource;\n        const isObjectSetting = types.isObject(value) &&\n            (property !== undefined && property.type === 'object' ||\n                property === undefined && (types.isUndefined(existingDefaultValue) || types.isObject(existingDefaultValue)));\n        // If the default value is an object, merge the objects and store the source of each keys\n        if (isObjectSetting) {\n            source = existingDefaultOverride?.source ?? new Map();\n            // This should not happen\n            if (!(source instanceof Map)) {\n                console.error('defaultValueSource is not a Map');\n                return undefined;\n            }\n            for (const objectKey in value) {\n                if (valuesSource) {\n                    source.set(`${propertyKey}.${objectKey}`, valuesSource);\n                }\n            }\n            value = { ...(types.isObject(existingDefaultValue) ? existingDefaultValue : {}), ...value };\n        }\n        return { value, source };\n    }\n    registerOverrideIdentifiers(overrideIdentifiers) {\n        this.doRegisterOverrideIdentifiers(overrideIdentifiers);\n        this._onDidSchemaChange.fire();\n    }\n    doRegisterOverrideIdentifiers(overrideIdentifiers) {\n        for (const overrideIdentifier of overrideIdentifiers) {\n            this.overrideIdentifiers.add(overrideIdentifier);\n        }\n        this.updateOverridePropertyPatternKey();\n    }\n    doRegisterConfigurations(configurations, validate, bucket) {\n        configurations.forEach(configuration => {\n            this.validateAndRegisterProperties(configuration, validate, configuration.extensionInfo, configuration.restrictedProperties, undefined, bucket);\n            this.configurationContributors.push(configuration);\n            this.registerJSONConfiguration(configuration);\n        });\n    }\n    validateAndRegisterProperties(configuration, validate = true, extensionInfo, restrictedProperties, scope = 3 /* ConfigurationScope.WINDOW */, bucket) {\n        scope = types.isUndefinedOrNull(configuration.scope) ? scope : configuration.scope;\n        const properties = configuration.properties;\n        if (properties) {\n            for (const key in properties) {\n                const property = properties[key];\n                if (validate && validateProperty(key, property)) {\n                    delete properties[key];\n                    continue;\n                }\n                property.source = extensionInfo;\n                // update default value\n                property.defaultDefaultValue = properties[key].default;\n                this.updatePropertyDefaultValue(key, property);\n                // update scope\n                if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n                    property.scope = undefined; // No scope for overridable properties `[${identifier}]`\n                }\n                else {\n                    property.scope = types.isUndefinedOrNull(property.scope) ? scope : property.scope;\n                    property.restricted = types.isUndefinedOrNull(property.restricted) ? !!restrictedProperties?.includes(key) : property.restricted;\n                }\n                // Add to properties maps\n                // Property is included by default if 'included' is unspecified\n                if (properties[key].hasOwnProperty('included') && !properties[key].included) {\n                    this.excludedConfigurationProperties[key] = properties[key];\n                    delete properties[key];\n                    continue;\n                }\n                else {\n                    this.configurationProperties[key] = properties[key];\n                    if (properties[key].policy?.name) {\n                        this.policyConfigurations.set(properties[key].policy.name, key);\n                    }\n                }\n                if (!properties[key].deprecationMessage && properties[key].markdownDeprecationMessage) {\n                    // If not set, default deprecationMessage to the markdown source\n                    properties[key].deprecationMessage = properties[key].markdownDeprecationMessage;\n                }\n                bucket.add(key);\n            }\n        }\n        const subNodes = configuration.allOf;\n        if (subNodes) {\n            for (const node of subNodes) {\n                this.validateAndRegisterProperties(node, validate, extensionInfo, restrictedProperties, scope, bucket);\n            }\n        }\n    }\n    getConfigurationProperties() {\n        return this.configurationProperties;\n    }\n    getPolicyConfigurations() {\n        return this.policyConfigurations;\n    }\n    registerJSONConfiguration(configuration) {\n        const register = (configuration) => {\n            const properties = configuration.properties;\n            if (properties) {\n                for (const key in properties) {\n                    this.updateSchema(key, properties[key]);\n                }\n            }\n            const subNodes = configuration.allOf;\n            subNodes?.forEach(register);\n        };\n        register(configuration);\n    }\n    updateSchema(key, property) {\n        allSettings.properties[key] = property;\n        switch (property.scope) {\n            case 1 /* ConfigurationScope.APPLICATION */:\n                applicationSettings.properties[key] = property;\n                break;\n            case 2 /* ConfigurationScope.MACHINE */:\n                machineSettings.properties[key] = property;\n                break;\n            case 6 /* ConfigurationScope.MACHINE_OVERRIDABLE */:\n                machineOverridableSettings.properties[key] = property;\n                break;\n            case 3 /* ConfigurationScope.WINDOW */:\n                windowSettings.properties[key] = property;\n                break;\n            case 4 /* ConfigurationScope.RESOURCE */:\n                resourceSettings.properties[key] = property;\n                break;\n            case 5 /* ConfigurationScope.LANGUAGE_OVERRIDABLE */:\n                resourceSettings.properties[key] = property;\n                this.resourceLanguageSettingsSchema.properties[key] = property;\n                break;\n        }\n    }\n    updateOverridePropertyPatternKey() {\n        for (const overrideIdentifier of this.overrideIdentifiers.values()) {\n            const overrideIdentifierProperty = `[${overrideIdentifier}]`;\n            const resourceLanguagePropertiesSchema = {\n                type: 'object',\n                description: nls.localize('overrideSettings.defaultDescription', \"Configure editor settings to be overridden for a language.\"),\n                errorMessage: nls.localize('overrideSettings.errorMessage', \"This setting does not support per-language configuration.\"),\n                $ref: resourceLanguageSettingsSchemaId,\n            };\n            this.updatePropertyDefaultValue(overrideIdentifierProperty, resourceLanguagePropertiesSchema);\n            allSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            applicationSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            machineSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            machineOverridableSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            windowSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n            resourceSettings.properties[overrideIdentifierProperty] = resourceLanguagePropertiesSchema;\n        }\n    }\n    registerOverridePropertyPatternKey() {\n        const resourceLanguagePropertiesSchema = {\n            type: 'object',\n            description: nls.localize('overrideSettings.defaultDescription', \"Configure editor settings to be overridden for a language.\"),\n            errorMessage: nls.localize('overrideSettings.errorMessage', \"This setting does not support per-language configuration.\"),\n            $ref: resourceLanguageSettingsSchemaId,\n        };\n        allSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        applicationSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        machineSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        machineOverridableSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        windowSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        resourceSettings.patternProperties[OVERRIDE_PROPERTY_PATTERN] = resourceLanguagePropertiesSchema;\n        this._onDidSchemaChange.fire();\n    }\n    updatePropertyDefaultValue(key, property) {\n        const configurationdefaultOverride = this.configurationDefaultsOverrides.get(key)?.configurationDefaultOverrideValue;\n        let defaultValue = undefined;\n        let defaultSource = undefined;\n        if (configurationdefaultOverride\n            && (!property.disallowConfigurationDefault || !configurationdefaultOverride.source) // Prevent overriding the default value if the property is disallowed to be overridden by configuration defaults from extensions\n        ) {\n            defaultValue = configurationdefaultOverride.value;\n            defaultSource = configurationdefaultOverride.source;\n        }\n        if (types.isUndefined(defaultValue)) {\n            defaultValue = property.defaultDefaultValue;\n            defaultSource = undefined;\n        }\n        if (types.isUndefined(defaultValue)) {\n            defaultValue = getDefaultValue(property.type);\n        }\n        property.default = defaultValue;\n        property.defaultValueSource = defaultSource;\n    }\n}\nconst OVERRIDE_IDENTIFIER_PATTERN = `\\\\[([^\\\\]]+)\\\\]`;\nconst OVERRIDE_IDENTIFIER_REGEX = new RegExp(OVERRIDE_IDENTIFIER_PATTERN, 'g');\nexport const OVERRIDE_PROPERTY_PATTERN = `^(${OVERRIDE_IDENTIFIER_PATTERN})+$`;\nexport const OVERRIDE_PROPERTY_REGEX = new RegExp(OVERRIDE_PROPERTY_PATTERN);\nexport function overrideIdentifiersFromKey(key) {\n    const identifiers = [];\n    if (OVERRIDE_PROPERTY_REGEX.test(key)) {\n        let matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);\n        while (matches?.length) {\n            const identifier = matches[1].trim();\n            if (identifier) {\n                identifiers.push(identifier);\n            }\n            matches = OVERRIDE_IDENTIFIER_REGEX.exec(key);\n        }\n    }\n    return distinct(identifiers);\n}\nexport function getDefaultValue(type) {\n    const t = Array.isArray(type) ? type[0] : type;\n    switch (t) {\n        case 'boolean':\n            return false;\n        case 'integer':\n        case 'number':\n            return 0;\n        case 'string':\n            return '';\n        case 'array':\n            return [];\n        case 'object':\n            return {};\n        default:\n            return null;\n    }\n}\nconst configurationRegistry = new ConfigurationRegistry();\nRegistry.add(Extensions.Configuration, configurationRegistry);\nexport function validateProperty(property, schema) {\n    if (!property.trim()) {\n        return nls.localize('config.property.empty', \"Cannot register an empty property\");\n    }\n    if (OVERRIDE_PROPERTY_REGEX.test(property)) {\n        return nls.localize('config.property.languageDefault', \"Cannot register '{0}'. This matches property pattern '\\\\\\\\[.*\\\\\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.\", property);\n    }\n    if (configurationRegistry.getConfigurationProperties()[property] !== undefined) {\n        return nls.localize('config.property.duplicate', \"Cannot register '{0}'. This property is already registered.\", property);\n    }\n    if (schema.policy?.name && configurationRegistry.getPolicyConfigurations().get(schema.policy?.name) !== undefined) {\n        return nls.localize('config.policy.duplicate', \"Cannot register '{0}'. The associated policy {1} is already registered with {2}.\", property, schema.policy?.name, configurationRegistry.getPolicyConfigurations().get(schema.policy?.name));\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport * as platform from '../../registry/common/platform.js';\nexport const Extensions = {\n    JSONContribution: 'base.contributions.json'\n};\nfunction normalizeId(id) {\n    if (id.length > 0 && id.charAt(id.length - 1) === '#') {\n        return id.substring(0, id.length - 1);\n    }\n    return id;\n}\nclass JSONContributionRegistry {\n    constructor() {\n        this._onDidChangeSchema = new Emitter();\n        this.schemasById = {};\n    }\n    registerSchema(uri, unresolvedSchemaContent) {\n        this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;\n        this._onDidChangeSchema.fire(uri);\n    }\n    notifySchemaChanged(uri) {\n        this._onDidChangeSchema.fire(uri);\n    }\n}\nconst jsonContributionRegistry = new JSONContributionRegistry();\nplatform.Registry.add(Extensions.JSONContribution, jsonContributionRegistry);\n","export const Mimes = Object.freeze({\n    text: 'text/plain',\n    binary: 'application/octet-stream',\n    unknown: 'application/unknown',\n    markdown: 'text/markdown',\n    latex: 'text/latex',\n    uriList: 'text/uri-list',\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Extensions as ConfigurationExtensions } from '../../../platform/configuration/common/configurationRegistry.js';\n// Define extension point ids\nexport const Extensions = {\n    ModesRegistry: 'editor.modesRegistry'\n};\nexport class EditorModesRegistry {\n    constructor() {\n        this._onDidChangeLanguages = new Emitter();\n        this.onDidChangeLanguages = this._onDidChangeLanguages.event;\n        this._languages = [];\n    }\n    registerLanguage(def) {\n        this._languages.push(def);\n        this._onDidChangeLanguages.fire(undefined);\n        return {\n            dispose: () => {\n                for (let i = 0, len = this._languages.length; i < len; i++) {\n                    if (this._languages[i] === def) {\n                        this._languages.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    getLanguages() {\n        return this._languages;\n    }\n}\nexport const ModesRegistry = new EditorModesRegistry();\nRegistry.add(Extensions.ModesRegistry, ModesRegistry);\nexport const PLAINTEXT_LANGUAGE_ID = 'plaintext';\nexport const PLAINTEXT_EXTENSION = '.txt';\nModesRegistry.registerLanguage({\n    id: PLAINTEXT_LANGUAGE_ID,\n    extensions: [PLAINTEXT_EXTENSION],\n    aliases: [nls.localize('plainText.alias', \"Plain Text\"), 'text'],\n    mimetypes: [Mimes.text]\n});\nRegistry.as(ConfigurationExtensions.Configuration)\n    .registerDefaultConfigurations([{\n        overrides: {\n            '[plaintext]': {\n                'editor.unicodeHighlight.ambiguousCharacters': false,\n                'editor.unicodeHighlight.invisibleCharacters': false\n            }\n        }\n    }]);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { parse } from '../../../base/common/glob.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { basename, posix } from '../../../base/common/path.js';\nimport { DataUri } from '../../../base/common/resources.js';\nimport { startsWithUTF8BOM } from '../../../base/common/strings.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nlet registeredAssociations = [];\nlet nonUserRegisteredAssociations = [];\nlet userRegisteredAssociations = [];\n/**\n * Associate a language to the registry (platform).\n * * **NOTE**: This association will lose over associations registered using `registerConfiguredLanguageAssociation`.\n * * **NOTE**: Use `clearPlatformLanguageAssociations` to remove all associations registered using this function.\n */\nexport function registerPlatformLanguageAssociation(association, warnOnOverwrite = false) {\n    _registerLanguageAssociation(association, false, warnOnOverwrite);\n}\nfunction _registerLanguageAssociation(association, userConfigured, warnOnOverwrite) {\n    // Register\n    const associationItem = toLanguageAssociationItem(association, userConfigured);\n    registeredAssociations.push(associationItem);\n    if (!associationItem.userConfigured) {\n        nonUserRegisteredAssociations.push(associationItem);\n    }\n    else {\n        userRegisteredAssociations.push(associationItem);\n    }\n    // Check for conflicts unless this is a user configured association\n    if (warnOnOverwrite && !associationItem.userConfigured) {\n        registeredAssociations.forEach(a => {\n            if (a.mime === associationItem.mime || a.userConfigured) {\n                return; // same mime or userConfigured is ok\n            }\n            if (associationItem.extension && a.extension === associationItem.extension) {\n                console.warn(`Overwriting extension <<${associationItem.extension}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.filename && a.filename === associationItem.filename) {\n                console.warn(`Overwriting filename <<${associationItem.filename}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {\n                console.warn(`Overwriting filepattern <<${associationItem.filepattern}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.firstline && a.firstline === associationItem.firstline) {\n                console.warn(`Overwriting firstline <<${associationItem.firstline}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n        });\n    }\n}\nfunction toLanguageAssociationItem(association, userConfigured) {\n    return {\n        id: association.id,\n        mime: association.mime,\n        filename: association.filename,\n        extension: association.extension,\n        filepattern: association.filepattern,\n        firstline: association.firstline,\n        userConfigured: userConfigured,\n        filenameLowercase: association.filename ? association.filename.toLowerCase() : undefined,\n        extensionLowercase: association.extension ? association.extension.toLowerCase() : undefined,\n        filepatternLowercase: association.filepattern ? parse(association.filepattern.toLowerCase()) : undefined,\n        filepatternOnPath: association.filepattern ? association.filepattern.indexOf(posix.sep) >= 0 : false\n    };\n}\n/**\n * Clear language associations from the registry (platform).\n */\nexport function clearPlatformLanguageAssociations() {\n    registeredAssociations = registeredAssociations.filter(a => a.userConfigured);\n    nonUserRegisteredAssociations = [];\n}\n/**\n * @see `getMimeTypes`\n */\nexport function getLanguageIds(resource, firstLine) {\n    return getAssociations(resource, firstLine).map(item => item.id);\n}\nfunction getAssociations(resource, firstLine) {\n    let path;\n    if (resource) {\n        switch (resource.scheme) {\n            case Schemas.file:\n                path = resource.fsPath;\n                break;\n            case Schemas.data: {\n                const metadata = DataUri.parseMetaData(resource);\n                path = metadata.get(DataUri.META_DATA_LABEL);\n                break;\n            }\n            case Schemas.vscodeNotebookCell:\n                // File path not relevant for language detection of cell\n                path = undefined;\n                break;\n            default:\n                path = resource.path;\n        }\n    }\n    if (!path) {\n        return [{ id: 'unknown', mime: Mimes.unknown }];\n    }\n    path = path.toLowerCase();\n    const filename = basename(path);\n    // 1.) User configured mappings have highest priority\n    const configuredLanguage = getAssociationByPath(path, filename, userRegisteredAssociations);\n    if (configuredLanguage) {\n        return [configuredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n    }\n    // 2.) Registered mappings have middle priority\n    const registeredLanguage = getAssociationByPath(path, filename, nonUserRegisteredAssociations);\n    if (registeredLanguage) {\n        return [registeredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n    }\n    // 3.) Firstline has lowest priority\n    if (firstLine) {\n        const firstlineLanguage = getAssociationByFirstline(firstLine);\n        if (firstlineLanguage) {\n            return [firstlineLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n        }\n    }\n    return [{ id: 'unknown', mime: Mimes.unknown }];\n}\nfunction getAssociationByPath(path, filename, associations) {\n    let filenameMatch = undefined;\n    let patternMatch = undefined;\n    let extensionMatch = undefined;\n    // We want to prioritize associations based on the order they are registered so that the last registered\n    // association wins over all other. This is for https://github.com/microsoft/vscode/issues/20074\n    for (let i = associations.length - 1; i >= 0; i--) {\n        const association = associations[i];\n        // First exact name match\n        if (filename === association.filenameLowercase) {\n            filenameMatch = association;\n            break; // take it!\n        }\n        // Longest pattern match\n        if (association.filepattern) {\n            if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {\n                const target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator\n                if (association.filepatternLowercase?.(target)) {\n                    patternMatch = association;\n                }\n            }\n        }\n        // Longest extension match\n        if (association.extension) {\n            if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {\n                if (filename.endsWith(association.extensionLowercase)) {\n                    extensionMatch = association;\n                }\n            }\n        }\n    }\n    // 1.) Exact name match has second highest priority\n    if (filenameMatch) {\n        return filenameMatch;\n    }\n    // 2.) Match on pattern\n    if (patternMatch) {\n        return patternMatch;\n    }\n    // 3.) Match on extension comes next\n    if (extensionMatch) {\n        return extensionMatch;\n    }\n    return undefined;\n}\nfunction getAssociationByFirstline(firstLine) {\n    if (startsWithUTF8BOM(firstLine)) {\n        firstLine = firstLine.substr(1);\n    }\n    if (firstLine.length > 0) {\n        // We want to prioritize associations based on the order they are registered so that the last registered\n        // association wins over all other. This is for https://github.com/microsoft/vscode/issues/20074\n        for (let i = registeredAssociations.length - 1; i >= 0; i--) {\n            const association = registeredAssociations[i];\n            if (!association.firstline) {\n                continue;\n            }\n            const matches = firstLine.match(association.firstline);\n            if (matches && matches.length > 0) {\n                return association;\n            }\n        }\n    }\n    return undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Assert from '../../../base/common/assert.js';\nimport * as Types from '../../../base/common/types.js';\nclass RegistryImpl {\n    constructor() {\n        this.data = new Map();\n    }\n    add(id, data) {\n        Assert.ok(Types.isString(id));\n        Assert.ok(Types.isObject(data));\n        Assert.ok(!this.data.has(id), 'There is already an extension with this id');\n        this.data.set(id, data);\n    }\n    as(id) {\n        return this.data.get(id) || null;\n    }\n}\nexport const Registry = new RegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { posix, sep } from './path.js';\nimport { isWindows } from './platform.js';\nimport { startsWithIgnoreCase } from './strings.js';\nexport function isPathSeparator(code) {\n    return code === 47 /* CharCode.Slash */ || code === 92 /* CharCode.Backslash */;\n}\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath) {\n    return osPath.replace(/[\\\\/]/g, posix.sep);\n}\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath) {\n    if (osPath.indexOf('/') === -1) {\n        osPath = toSlashes(osPath);\n    }\n    if (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n        osPath = '/' + osPath;\n    }\n    return osPath;\n}\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path, sep = posix.sep) {\n    if (!path) {\n        return '';\n    }\n    const len = path.length;\n    const firstLetter = path.charCodeAt(0);\n    if (isPathSeparator(firstLetter)) {\n        if (isPathSeparator(path.charCodeAt(1))) {\n            // UNC candidate \\\\localhost\\shares\\ddd\n            //               ^^^^^^^^^^^^^^^^^^^\n            if (!isPathSeparator(path.charCodeAt(2))) {\n                let pos = 3;\n                const start = pos;\n                for (; pos < len; pos++) {\n                    if (isPathSeparator(path.charCodeAt(pos))) {\n                        break;\n                    }\n                }\n                if (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n                    pos += 1;\n                    for (; pos < len; pos++) {\n                        if (isPathSeparator(path.charCodeAt(pos))) {\n                            return path.slice(0, pos + 1) // consume this separator\n                                .replace(/[\\\\/]/g, sep);\n                        }\n                    }\n                }\n            }\n        }\n        // /user/far\n        // ^\n        return sep;\n    }\n    else if (isWindowsDriveLetter(firstLetter)) {\n        // check for windows drive letter c:\\ or c:\n        if (path.charCodeAt(1) === 58 /* CharCode.Colon */) {\n            if (isPathSeparator(path.charCodeAt(2))) {\n                // C:\\fff\n                // ^^^\n                return path.slice(0, 2) + sep;\n            }\n            else {\n                // C:\n                // ^^\n                return path.slice(0, 2);\n            }\n        }\n    }\n    // check for URI\n    // scheme://authority/path\n    // ^^^^^^^^^^^^^^^^^^^\n    let pos = path.indexOf('://');\n    if (pos !== -1) {\n        pos += 3; // 3 -> \"://\".length\n        for (; pos < len; pos++) {\n            if (isPathSeparator(path.charCodeAt(pos))) {\n                return path.slice(0, pos + 1); // consume this separator\n            }\n        }\n    }\n    return '';\n}\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base, parentCandidate, ignoreCase, separator = sep) {\n    if (base === parentCandidate) {\n        return true;\n    }\n    if (!base || !parentCandidate) {\n        return false;\n    }\n    if (parentCandidate.length > base.length) {\n        return false;\n    }\n    if (ignoreCase) {\n        const beginsWith = startsWithIgnoreCase(base, parentCandidate);\n        if (!beginsWith) {\n            return false;\n        }\n        if (parentCandidate.length === base.length) {\n            return true; // same path, different casing\n        }\n        let sepOffset = parentCandidate.length;\n        if (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n            sepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n        }\n        return base.charAt(sepOffset) === separator;\n    }\n    if (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n        parentCandidate += separator;\n    }\n    return base.indexOf(parentCandidate) === 0;\n}\nexport function isWindowsDriveLetter(char0) {\n    return char0 >= 65 /* CharCode.A */ && char0 <= 90 /* CharCode.Z */ || char0 >= 97 /* CharCode.a */ && char0 <= 122 /* CharCode.z */;\n}\nexport function hasDriveLetter(path, isWindowsOS = isWindows) {\n    if (isWindowsOS) {\n        return isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === 58 /* CharCode.Colon */;\n    }\n    return false;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// ------ internal util\nexport var _util;\n(function (_util) {\n    _util.serviceIds = new Map();\n    _util.DI_TARGET = '$di$target';\n    _util.DI_DEPENDENCIES = '$di$dependencies';\n    function getServiceDependencies(ctor) {\n        return ctor[_util.DI_DEPENDENCIES] || [];\n    }\n    _util.getServiceDependencies = getServiceDependencies;\n})(_util || (_util = {}));\nexport const IInstantiationService = createDecorator('instantiationService');\nfunction storeServiceDependency(id, target, index) {\n    if (target[_util.DI_TARGET] === target) {\n        target[_util.DI_DEPENDENCIES].push({ id, index });\n    }\n    else {\n        target[_util.DI_DEPENDENCIES] = [{ id, index }];\n        target[_util.DI_TARGET] = target;\n    }\n}\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator(serviceId) {\n    if (_util.serviceIds.has(serviceId)) {\n        return _util.serviceIds.get(serviceId);\n    }\n    const id = function (target, key, index) {\n        if (arguments.length !== 3) {\n            throw new Error('@IServiceName-decorator can only be used to decorate a parameter');\n        }\n        storeServiceDependency(id, target, index);\n    };\n    id.toString = () => serviceId;\n    _util.serviceIds.set(serviceId, id);\n    return id;\n}\n","import { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n            //           in which case also matches (Path Sep followed by Path Val)\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Treat globstar specially\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            // Anything else, not globstar\n            else {\n                // States\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    // Support brace expansion\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    // Support brackets\n                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                        let res;\n                        // range operator\n                        if (char === '-') {\n                            res = char;\n                        }\n                        // negation operator (only valid on first index in bracket)\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        // glob split matching is not allowed within character ranges\n                        // see http://man7.org/linux/man-pages/man7/glob.7.html\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        // anything else gets escaped\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            // Converts {foo,bar} => [foo|bar]\n                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                // Tail: Add the slash we had split on if there is more to\n                // come and the remaining pattern is not a globstar\n                // For example if pattern: some/**/*.js we want the \"/\" after\n                // some to be included in the RegEx to prevent a folder called\n                // \"something\" to match as well.\n                if (index < segments.length - 1 && // more segments to come after this\n                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n                        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            // update globstar state\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle relative patterns\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        // For that we try to extract the portion of the `path`\n        // that comes after the `base` portion. We have to account\n        // for the fact that `base` might end in a path separator\n        // (https://github.com/microsoft/vscode/issues/162498)\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    // Make sure to preserve associated metadata\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result; // immediately return as soon as the first expression matches\n                }\n                // If the result is a promise, we have to keep it for\n                // later processing and await the result properly.\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            // With result promises, we have to loop over each and\n            // await the result before we can return any result.\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result; // immediately return as soon as the first expression matches\n            }\n            // If the result is a promise, we have to keep it for\n            // later processing and await the result properly.\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        // With result promises, we have to loop over each and\n        // await the result before we can return any result.\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IConfigurationService = createDecorator('configurationService');\nexport function toValuesTree(properties, conflictReporter) {\n    const root = Object.create(null);\n    for (const key in properties) {\n        addToValueTree(root, key, properties[key], conflictReporter);\n    }\n    return root;\n}\nexport function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {\n    const segments = key.split('.');\n    const last = segments.pop();\n    let curr = settingsTreeRoot;\n    for (let i = 0; i < segments.length; i++) {\n        const s = segments[i];\n        let obj = curr[s];\n        switch (typeof obj) {\n            case 'undefined':\n                obj = curr[s] = Object.create(null);\n                break;\n            case 'object':\n                if (obj === null) {\n                    conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is null`);\n                    return;\n                }\n                break;\n            default:\n                conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);\n                return;\n        }\n        curr = obj;\n    }\n    if (typeof curr === 'object' && curr !== null) {\n        try {\n            curr[last] = value; // workaround https://github.com/microsoft/vscode/issues/13606\n        }\n        catch (e) {\n            conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n        }\n    }\n    else {\n        conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n    }\n}\nexport function removeFromValueTree(valueTree, key) {\n    const segments = key.split('.');\n    doRemoveFromValueTree(valueTree, segments);\n}\nfunction doRemoveFromValueTree(valueTree, segments) {\n    const first = segments.shift();\n    if (segments.length === 0) {\n        // Reached last segment\n        delete valueTree[first];\n        return;\n    }\n    if (Object.keys(valueTree).indexOf(first) !== -1) {\n        const value = valueTree[first];\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            doRemoveFromValueTree(value, segments);\n            if (Object.keys(value).length === 0) {\n                delete valueTree[first];\n            }\n        }\n    }\n}\n/**\n * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)\n */\nexport function getConfigurationValue(config, settingPath, defaultValue) {\n    function accessSetting(config, path) {\n        let current = config;\n        for (const component of path) {\n            if (typeof current !== 'object' || current === null) {\n                return undefined;\n            }\n            current = current[component];\n        }\n        return current;\n    }\n    const path = settingPath.split('.');\n    const result = accessSetting(config, path);\n    return typeof result === 'undefined' ? defaultValue : result;\n}\nexport function getLanguageTagSettingPlainKey(settingKey) {\n    return settingKey.replace(/[\\[\\]]/g, '');\n}\n"],"names":["originalFSPath","uri","ExtUri","constructor","_ignorePathCasing","this","compare","uri1","uri2","ignoreFragment","getComparisonKey","isEqual","with","path","toLowerCase","undefined","fragment","toString","isEqualOrParent","base","parentCandidate","scheme","file","query","isEqualAuthority","authority","joinPath","resource","pathFragment","basenameOrAuthority","basename","extname","dirname","length","charCodeAt","console","error","normalizePath","normalizedPath","normalize","relativePath","from","to","fromPath","toPath","i","len","Math","min","charAt","substr","relative","resolvePath","newURI","resolve","isAbsolutePath","a1","a2","hasTrailingPathSeparator","sep","fsp","p","test","fsPath","removeTrailingPathSeparator","addTrailingPathSeparator","isRootSep","extUri","_","bind","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","substring","indexOf","lastIndexOf","split","forEach","property","key","value","set","mime","Extensions","Configuration","allSettings","properties","patternProperties","applicationSettings","machineSettings","machineOverridableSettings","windowSettings","resourceSettings","resourceLanguageSettingsSchemaId","contributionRegistry","as","JSONContribution","OVERRIDE_IDENTIFIER_PATTERN","OVERRIDE_IDENTIFIER_REGEX","RegExp","OVERRIDE_PROPERTY_PATTERN","OVERRIDE_PROPERTY_REGEX","overrideIdentifiersFromKey","identifiers","matches","exec","identifier","trim","push","configurationRegistry","registeredConfigurationDefaults","overrideIdentifiers","Set","_onDidSchemaChange","_onDidUpdateConfiguration","configurationDefaultsOverrides","defaultLanguageConfigurationOverridesNode","id","title","configurationContributors","resourceLanguageSettingsSchema","additionalProperties","allowTrailingCommas","allowComments","configurationProperties","policyConfigurations","excludedConfigurationProperties","registerSchema","registerOverridePropertyPatternKey","registerConfiguration","configuration","validate","registerConfigurations","configurations","doRegisterConfigurations","fire","registerDefaultConfigurations","configurationDefaults","doRegisterDefaultConfigurations","defaultsOverrides","bucket","overrides","source","add","configurationDefaultOverridesForKey","get","configurationDefaultOverrides","newDefaultOverride","mergeDefaultConfigurationsForOverrideIdentifier","configurationDefaultOverrideValue","updateDefaultOverrideProperty","mergeDefaultConfigurationsForConfigurationProperty","updatePropertyDefaultValue","updateSchema","doRegisterOverrideIdentifiers","type","default","description","$ref","defaultDefaultValue","defaultValueSource","overrideIdentifier","configurationValueObject","valueSource","existingDefaultOverride","defaultValue","propertyKey","Object","keys","propertyDefaultValue","objectKey","delete","valuesSource","existingDefaultValue","registerOverrideIdentifiers","updateOverridePropertyPatternKey","validateAndRegisterProperties","extensionInfo","restrictedProperties","registerJSONConfiguration","scope","validateProperty","restricted","includes","hasOwnProperty","included","policy","name","deprecationMessage","markdownDeprecationMessage","subNodes","allOf","node","getConfigurationProperties","getPolicyConfigurations","register","values","overrideIdentifierProperty","resourceLanguagePropertiesSchema","errorMessage","configurationdefaultOverride","defaultSource","disallowConfigurationDefault","Array","isArray","getDefaultValue","schema","jsonContributionRegistry","_onDidChangeSchema","schemasById","unresolvedSchemaContent","notifySchemaChanged","Mimes","freeze","text","binary","unknown","markdown","latex","uriList","ModesRegistry","_onDidChangeLanguages","onDidChangeLanguages","event","_languages","registerLanguage","def","dispose","splice","getLanguages","PLAINTEXT_LANGUAGE_ID","extensions","aliases","mimetypes","registeredAssociations","nonUserRegisteredAssociations","userRegisteredAssociations","registerPlatformLanguageAssociation","association","warnOnOverwrite","userConfigured","associationItem","filename","extension","filepattern","firstline","filenameLowercase","extensionLowercase","filepatternLowercase","filepatternOnPath","toLanguageAssociationItem","a","warn","_registerLanguageAssociation","clearPlatformLanguageAssociations","filter","getLanguageIds","firstLine","data","vscodeNotebookCell","configuredLanguage","getAssociationByPath","registeredLanguage","firstlineLanguage","match","getAssociationByFirstline","getAssociations","map","item","associations","filenameMatch","patternMatch","extensionMatch","target","endsWith","Registry","has","isPathSeparator","code","toSlashes","osPath","replace","toPosixPath","getRoot","firstLetter","pos","start","slice","isWindowsDriveLetter","ignoreCase","separator","sepOffset","char0","hasDriveLetter","isWindowsOS","_util","serviceIds","DI_TARGET","DI_DEPENDENCIES","getServiceDependencies","ctor","IInstantiationService","createDecorator","serviceId","index","arguments","Error","storeServiceDependency","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","parseRegExp","regEx","every","segment","previousSegmentWasGlobStar","braceVal","bracketVal","braceRegExp","choice","join","res","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","patternKey","trimForExclusions","parsedPattern","trivia1","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","parsedPatterns","aggregateBasenameMatches","patternsLength","n","withBasenames","find","allPaths","reduce","all","current","concat","trivia3","trivia4and5","regExp","lastIndex","toRegExp","wrapRelativePattern","arg2","wrappedPattern","targetPath","matchPathEnds","usingPosixSep","nativePath","nativePathEnd","targetPathEnd","hasSibling","parse","obj","rp","isRelativePattern","resultPattern","expression","getOwnPropertyNames","when","result","matched","then","requiresSiblings","parseExpressionPattern","some","resultExpression","resultPromises","resultPromise","parsedExpression","basenamePatterns","aggregate","ch","aggregatedPatterns","IConfigurationService","toValuesTree","conflictReporter","root","create","addToValueTree","settingsTreeRoot","last","pop","curr","s","JSON","stringify","e","removeFromValueTree","valueTree","doRemoveFromValueTree","first","shift","getConfigurationValue","config","settingPath","component","accessSetting","getLanguageTagSettingPlainKey","settingKey"],"sourceRoot":""}