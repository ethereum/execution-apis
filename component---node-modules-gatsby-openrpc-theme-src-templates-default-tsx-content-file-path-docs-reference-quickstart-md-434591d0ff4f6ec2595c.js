"use strict";(self.webpackChunkexecution_apis=self.webpackChunkexecution_apis||[]).push([[9842],{18007:function(e,t,n){n.r(t),n.d(t,{default:function(){return g}});var a=n(55569),l=n(96540);function c(e){const t=Object.assign({h1:"h1",h2:"h2",p:"p",a:"a",h3:"h3",pre:"pre",code:"code",h4:"h4"},(0,a.R)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.h1,{id:"execution-api-specification"},"Execution API Specification"),"\n",l.createElement(t.h2,{id:"json-rpc"},"JSON-RPC"),"\n",l.createElement(t.p,null,l.createElement(t.a,{href:"https://ethereum.github.io/execution-apis/docs/reference/json-rpc-api"},"View the spec")),"\n",l.createElement(t.p,null,"The Ethereum JSON-RPC is a standard collection of methods that all execution\nclients implement. It is the canonical interface between users and the network.\nThis interface allows downstream tooling and infrastructure to treat different\nEthereum clients as modules that can be swapped at will."),"\n",l.createElement(t.h3,{id:"contributing"},"Contributing"),"\n",l.createElement(t.p,null,"Please see the ",l.createElement(t.a,{href:"docs/reference/contributors-guide.md"},"contributors guide"),"\nfor general information about the process of standardizing new API methods and\nmaking changes to existing ones. Information on test generation can be found\nin ",l.createElement(t.a,{href:"docs/reference/tests.md"},"test-gen")),"\n",l.createElement(t.p,null,"The specification itself is written in ",l.createElement(t.a,{href:"https://open-rpc.org"},"OpenRPC"),". Refer to the OpenRPC\nspecification and the JSON schema ",l.createElement(t.a,{href:"https://json-schema.org"},"specification")," to get started."),"\n",l.createElement(t.h3,{id:"building"},"Building"),"\n",l.createElement(t.p,null,"The specification is split into multiple files to improve readability. The\nspec can be compiled into a single document as follows:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-console"},"$ npm install\n$ npm run build\nBuild successful.\n")),"\n",l.createElement(t.p,null,"This will output the file ",l.createElement(t.code,null,"openrpc.json")," in the root of the project. This file\nwill have all schema ",l.createElement(t.code,null,"#ref"),"s resolved."),"\n",l.createElement(t.h4,{id:"testing"},"Testing"),"\n",l.createElement(t.p,null,"There are several mechanisms for testing specification contributions and client\nconformance."),"\n",l.createElement(t.p,null,"First is the ",l.createElement(t.a,{href:"https://open-rpc.github.io/schema-utils-js/functions/validateOpenRPCDocument.html"},"OpenRPC validator"),". It performs some basic syntactic\nchecks on the generated specification."),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-console"},"$ npm install\n$ npm run lint\nOpenRPC spec validated successfully.\n")),"\n",l.createElement(t.p,null,"Next is ",l.createElement(t.code,null,"speccheck"),". This tool validates the test cases in the ",l.createElement(t.code,null,"tests"),"\ndirectory against the specification."),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-console"},"$ go install github.com/lightclient/rpctestgen/cmd/speccheck@latest\n$ speccheck -v\nall passing.\n")),"\n",l.createElement(t.p,null,"If you get an error that says: ",l.createElement(t.code,null,"speccheck: command not found"),",\nmake sure that the go binary is in your $PATH:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-console"},"$ export PATH=$HOME/go/bin:$PATH\n")),"\n",l.createElement(t.p,null,"The spell checker ensures the specification is free of spelling errors."),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-console"},"$ pip install pyspelling\n$ pyspelling -c spellcheck.yaml\nSpelling check passed :)\n")),"\n",l.createElement(t.p,null,"pyspelling is a wrapper around either ",l.createElement(t.a,{href:"http://aspell.net/"},"Aspell")," or\n",l.createElement(t.a,{href:"https://hunspell.github.io/"},"Hunspell"),". You'll need to install\none of those before running ",l.createElement(t.code,null,"pyspelling"),"."),"\n",l.createElement(t.p,null,"Finally, the test cases in the ",l.createElement(t.code,null,"tests/")," directory may be run against individual\nexecution client using the [",l.createElement(t.code,null,"hive"),"] simulator ",l.createElement(t.a,{href:"https://github.com/ethereum/hive/tree/master/simulators/ethereum/rpc-compat"},l.createElement(t.code,null,"rpc-compat")),".\nPlease see the documentation in the aforementioned repositories for more\ninformation."),"\n",l.createElement(t.h2,{id:"graphql"},"GraphQL"),"\n",l.createElement(t.p,null,l.createElement(t.a,{href:"http://graphql-schema.ethdevops.io/?url=https://raw.githubusercontent.com/ethereum/execution-apis/main/graphql.json"},"View the spec")),"\n",l.createElement(t.p,null,l.createElement(t.a,{href:"https://eips.ethereum.org/EIPS/eip-1767"},"EIP-1767")," proposed a GraphQL schema for interacting with Ethereum clients. Since then Besu and Geth have implemented the interface. This repo contains a live specification to integrate changes to the protocol as well as other improvements into the GraphQL schema."),"\n",l.createElement(t.h3,{id:"generation"},"Generation"),"\n",l.createElement(t.p,null,"The schema in this repo is generated by issuing a meta GraphQL query against a live node. This can be done as follows:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-console"},"$ npm run graphql:schema\n")),"\n",l.createElement(t.h3,{id:"testing-1"},"Testing"),"\n",l.createElement(t.p,null,"A script is included in the source code which reads and validates the given schema to be a valid one. It is recommended to perform this check after modifying the schema by:"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-console"},"$ npm run graphql:validate\n")),"\n",l.createElement(t.h2,{id:"license"},"License"),"\n",l.createElement(t.p,null,"This repository is licensed under ",l.createElement(t.a,{href:"LICENSE"},"CC0"),"."))}var r=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.R)(),e.components);return t?l.createElement(t,e,l.createElement(c,e)):c(e)},i=n(24794),s=n(28453),o=n(33551),m=n(87164),h=n(64155),p=n(91890);const u={h1:e=>l.createElement(o.A,Object.assign({variant:"h1"},e)),h2:e=>l.createElement(o.A,Object.assign({variant:"h2"},e)),h3:e=>l.createElement(o.A,Object.assign({variant:"h3"},e)),h4:e=>l.createElement(o.A,Object.assign({variant:"h4"},e)),h5:e=>l.createElement(o.A,Object.assign({variant:"h5"},e)),h6:e=>l.createElement(o.A,Object.assign({variant:"h6"},e)),p:e=>l.createElement(o.A,Object.assign({paragraph:!0},e)),a:e=>l.createElement(i.Link,e),pre:e=>l.createElement(m.A,Object.assign({component:"pre",sx:{overflowX:"auto",p:2,bgcolor:"background.paper",borderRadius:1,mb:2}},e)),code:e=>l.createElement(m.A,Object.assign({component:"code",sx:{fontFamily:"monospace",p:.5,borderRadius:.5}},e))},d=e=>{let{children:t,pageContext:n}=e;return l.createElement(l.Fragment,null,l.createElement(h.A,{elevation:0,sx:{p:3,mb:4}},l.createElement(s.xA,{components:u},t),l.createElement(p.A,{next:n.next,prev:n.prev})))};function g(e){return l.createElement(d,e,l.createElement(r,e))}}}]);
//# sourceMappingURL=component---node-modules-gatsby-openrpc-theme-src-templates-default-tsx-content-file-path-docs-reference-quickstart-md-434591d0ff4f6ec2595c.js.map