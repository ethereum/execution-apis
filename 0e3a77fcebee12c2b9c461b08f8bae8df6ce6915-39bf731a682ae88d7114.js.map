{"version":3,"file":"0e3a77fcebee12c2b9c461b08f8bae8df6ce6915-39bf731a682ae88d7114.js","mappings":"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","sources":["webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/equals.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/markers/common/markers.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/utils.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/themables.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/numbers.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/severity.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorations.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeaturesService.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/environment/common/environment.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/base/common/collections.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/platform/files/common/files.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorker.js","webpack://execution-apis/./node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nexport function createBracketOrRegExp(pieces, options) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true, options);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\n/**\n * Compares two items for equality using strict equality.\n*/\nexport const strictEquals = (a, b) => a === b;\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nexport function itemsEquals(itemEquals = strictEquals) {\n    return (a, b) => arrays.equals(a, b, itemEquals);\n}\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nexport function itemEquals() {\n    return (a, b) => a.equals(b);\n}\nexport function equalsIfDefined(equalsOrV1, v2, equals) {\n    if (equals !== undefined) {\n        const v1 = equalsOrV1;\n        if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n            return v2 === v1;\n        }\n        return equals(v1, v2);\n    }\n    else {\n        const equals = equalsOrV1;\n        return (v1, v2) => {\n            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n                return v2 === v1;\n            }\n            return equals(v1, v2);\n        };\n    }\n}\n/**\n * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.\n*/\nexport function structuralEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!structuralEquals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && typeof a === 'object' && b && typeof b === 'object') {\n        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n            const aObj = a;\n            const bObj = b;\n            const keysA = Object.keys(aObj);\n            const keysB = Object.keys(bObj);\n            const keysBSet = new Set(keysB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            }\n            for (const key of keysA) {\n                if (!keysBSet.has(key)) {\n                    return false;\n                }\n                if (!structuralEquals(aObj[key], bObj[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nconst objIds = new WeakMap();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LineRange } from '../core/lineRange.js';\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\nexport class AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nexport class AbstractTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeSitterTokenizationRegistry } from '../languages.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { AbstractTokens } from './tokens.js';\nexport class TreeSitterTokens extends AbstractTokens {\n    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {\n        super(languageIdCodec, textModel, languageId);\n        this._treeSitterService = _treeSitterService;\n        this._tokenizationSupport = null;\n        this._initialize();\n    }\n    _initialize() {\n        const newLanguage = this.getLanguageId();\n        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {\n            this._lastLanguageId = newLanguage;\n            this._tokenizationSupport = TreeSitterTokenizationRegistry.get(newLanguage);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        if (this._tokenizationSupport) {\n            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);\n            if (rawTokens) {\n                return new LineTokens(rawTokens, content, this._languageIdCodec);\n            }\n        }\n        return LineTokens.createEmpty(content, this._languageIdCodec);\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        this._initialize();\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n    }\n    forceTokenization(lineNumber) {\n        // TODO @alexr00 implement\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        // TODO @alexr00 understand what this is for and implement\n        return null;\n    }\n    get hasTokens() {\n        // TODO @alexr00 once we have a token store, implement properly\n        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;\n        return hasTree;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { doHash } from '../../../base/common/hash.js';\nimport { LRUCache } from '../../../base/common/map.js';\nimport { clamp, MovingAverage, SlidingWindowAverage } from '../../../base/common/numbers.js';\nimport { IEnvironmentService } from '../../../platform/environment/common/environment.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { matchesScheme } from '../../../base/common/network.js';\nexport const ILanguageFeatureDebounceService = createDecorator('ILanguageFeatureDebounceService');\nvar IdentityHash;\n(function (IdentityHash) {\n    const _hashes = new WeakMap();\n    let pool = 0;\n    function of(obj) {\n        let value = _hashes.get(obj);\n        if (value === undefined) {\n            value = ++pool;\n            _hashes.set(obj, value);\n        }\n        return value;\n    }\n    IdentityHash.of = of;\n})(IdentityHash || (IdentityHash = {}));\nclass NullDebounceInformation {\n    constructor(_default) {\n        this._default = _default;\n    }\n    get(_model) {\n        return this._default;\n    }\n    update(_model, _value) {\n        return this._default;\n    }\n    default() {\n        return this._default;\n    }\n}\nclass FeatureDebounceInformation {\n    constructor(_logService, _name, _registry, _default, _min, _max) {\n        this._logService = _logService;\n        this._name = _name;\n        this._registry = _registry;\n        this._default = _default;\n        this._min = _min;\n        this._max = _max;\n        this._cache = new LRUCache(50, 0.7);\n    }\n    _key(model) {\n        return model.id + this._registry.all(model).reduce((hashVal, obj) => doHash(IdentityHash.of(obj), hashVal), 0);\n    }\n    get(model) {\n        const key = this._key(model);\n        const avg = this._cache.get(key);\n        return avg\n            ? clamp(avg.value, this._min, this._max)\n            : this.default();\n    }\n    update(model, value) {\n        const key = this._key(model);\n        let avg = this._cache.get(key);\n        if (!avg) {\n            avg = new SlidingWindowAverage(6);\n            this._cache.set(key, avg);\n        }\n        const newValue = clamp(avg.update(value), this._min, this._max);\n        if (!matchesScheme(model.uri, 'output')) {\n            this._logService.trace(`[DEBOUNCE: ${this._name}] for ${model.uri.toString()} is ${newValue}ms`);\n        }\n        return newValue;\n    }\n    _overall() {\n        const result = new MovingAverage();\n        for (const [, avg] of this._cache) {\n            result.update(avg.value);\n        }\n        return result.value;\n    }\n    default() {\n        const value = (this._overall() | 0) || this._default;\n        return clamp(value, this._min, this._max);\n    }\n}\nlet LanguageFeatureDebounceService = class LanguageFeatureDebounceService {\n    constructor(_logService, envService) {\n        this._logService = _logService;\n        this._data = new Map();\n        this._isDev = envService.isExtensionDevelopment || !envService.isBuilt;\n    }\n    for(feature, name, config) {\n        const min = config?.min ?? 50;\n        const max = config?.max ?? min ** 2;\n        const extra = config?.key ?? undefined;\n        const key = `${IdentityHash.of(feature)},${min}${extra ? ',' + extra : ''}`;\n        let info = this._data.get(key);\n        if (!info) {\n            if (this._isDev) {\n                this._logService.debug(`[DEBOUNCE: ${name}] is disabled in developed mode`);\n                info = new NullDebounceInformation(min * 1.5);\n            }\n            else {\n                info = new FeatureDebounceInformation(this._logService, name, feature, (this._overallAverage() | 0) || (min * 1.5), // default is overall default or derived from min-value\n                min, max);\n            }\n            this._data.set(key, info);\n        }\n        return info;\n    }\n    _overallAverage() {\n        // Average of all language features. Not a great value but an approximation\n        const result = new MovingAverage();\n        for (const info of this._data.values()) {\n            result.update(info.default());\n        }\n        return result.value;\n    }\n};\nLanguageFeatureDebounceService = __decorate([\n    __param(0, ILogService),\n    __param(1, IEnvironmentService)\n], LanguageFeatureDebounceService);\nexport { LanguageFeatureDebounceService };\nregisterSingleton(ILanguageFeatureDebounceService, LanguageFeatureDebounceService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event } from '../event.js';\nimport { DisposableStore, toDisposable } from '../lifecycle.js';\nimport { BaseObservable, ConvenientObservable, _setKeepObserved, _setRecomputeInitiallyAndOnChange, subtransaction, transaction } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\nimport { strictEquals } from '../equals.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nexport function observableFromEvent(...args) {\n    let owner;\n    let event;\n    let getValue;\n    if (args.length === 3) {\n        [owner, event, getValue] = args;\n    }\n    else {\n        [event, getValue] = args;\n    }\n    return new FromEventObservable(new DebugNameData(owner, undefined, getValue), event, getValue, () => FromEventObservable.globalTransaction, strictEquals);\n}\nexport function observableFromEventOpts(options, event, getValue) {\n    return new FromEventObservable(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue), event, getValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals);\n}\nexport class FromEventObservable extends BaseObservable {\n    constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this.event = event;\n        this._getValue = _getValue;\n        this._getTransaction = _getTransaction;\n        this._equalityComparator = _equalityComparator;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            const newValue = this._getValue(args);\n            const oldValue = this.value;\n            const didChange = !this.hasValue || !(this._equalityComparator(oldValue, newValue));\n            let didRunTransaction = false;\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    didRunTransaction = true;\n                    subtransaction(this._getTransaction(), (tx) => {\n                        getLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n            if (!didRunTransaction) {\n                getLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n            }\n        };\n    }\n    getDebugName() {\n        return this._debugNameData.getDebugName(this);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            const value = this._getValue(undefined);\n            return value;\n        }\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n    function batchEventsGlobally(tx, fn) {\n        let didSet = false;\n        if (FromEventObservable.globalTransaction === undefined) {\n            FromEventObservable.globalTransaction = tx;\n            didSet = true;\n        }\n        try {\n            fn();\n        }\n        finally {\n            if (didSet) {\n                FromEventObservable.globalTransaction = undefined;\n            }\n        }\n    }\n    observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n    return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\nexport function observableSignal(debugNameOrOwner) {\n    if (typeof debugNameOrOwner === 'string') {\n        return new ObservableSignal(debugNameOrOwner);\n    }\n    else {\n        return new ObservableSignal(undefined, debugNameOrOwner);\n    }\n}\nclass ObservableSignal extends BaseObservable {\n    get debugName() {\n        return new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n    }\n    toString() {\n        return this.debugName;\n    }\n    constructor(_debugName, _owner) {\n        super();\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved(observable) {\n    const o = new KeepAliveObserver(false, undefined);\n    observable.addObserver(o);\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setKeepObserved(keepObserved);\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable, handleValue) {\n    const o = new KeepAliveObserver(true, handleValue);\n    observable.addObserver(o);\n    if (handleValue) {\n        handleValue(observable.get());\n    }\n    else {\n        observable.reportChanges();\n    }\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nexport class KeepAliveObserver {\n    constructor(_forceRecompute, _handleValue) {\n        this._forceRecompute = _forceRecompute;\n        this._handleValue = _handleValue;\n        this._counter = 0;\n    }\n    beginUpdate(observable) {\n        this._counter++;\n    }\n    endUpdate(observable) {\n        this._counter--;\n        if (this._counter === 0 && this._forceRecompute) {\n            if (this._handleValue) {\n                this._handleValue(observable.get());\n            }\n            else {\n                observable.reportChanges();\n            }\n        }\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\nexport function derivedObservableWithCache(owner, computeFn) {\n    let lastValue = undefined;\n    const observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return observable;\n}\nexport function derivedObservableWithWritableCache(owner, computeFn) {\n    let lastValue = undefined;\n    const onChange = observableSignal('derivedObservableWithWritableCache');\n    const observable = derived(owner, reader => {\n        onChange.read(reader);\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return Object.assign(observable, {\n        clearCache: (tx) => {\n            lastValue = undefined;\n            onChange.trigger(tx);\n        },\n        setCache: (newValue, tx) => {\n            lastValue = newValue;\n            onChange.trigger(tx);\n        }\n    });\n}\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached(owner, items, map, keySelector) {\n    let m = new ArrayMap(map, keySelector);\n    const self = derivedOpts({\n        debugReferenceFn: map,\n        owner,\n        onLastObserverRemoved: () => {\n            m.dispose();\n            m = new ArrayMap(map);\n        }\n    }, (reader) => {\n        m.setItems(items.read(reader));\n        return m.getItems();\n    });\n    return self;\n}\nclass ArrayMap {\n    constructor(_map, _keySelector) {\n        this._map = _map;\n        this._keySelector = _keySelector;\n        this._cache = new Map();\n        this._items = [];\n    }\n    dispose() {\n        this._cache.forEach(entry => entry.store.dispose());\n        this._cache.clear();\n    }\n    setItems(items) {\n        const newItems = [];\n        const itemsToRemove = new Set(this._cache.keys());\n        for (const item of items) {\n            const key = this._keySelector ? this._keySelector(item) : item;\n            let entry = this._cache.get(key);\n            if (!entry) {\n                const store = new DisposableStore();\n                const out = this._map(item, store);\n                entry = { out, store };\n                this._cache.set(key, entry);\n            }\n            else {\n                itemsToRemove.delete(key);\n            }\n            newItems.push(entry.out);\n        }\n        for (const item of itemsToRemove) {\n            const entry = this._cache.get(item);\n            entry.store.dispose();\n            this._cache.delete(item);\n        }\n        this._items = newItems;\n    }\n    getItems() {\n        return this._items;\n    }\n}\nexport class ValueWithChangeEventFromObservable {\n    constructor(observable) {\n        this.observable = observable;\n    }\n    get onDidChange() {\n        return Event.fromObservableLight(this.observable);\n    }\n    get value() {\n        return this.observable.get();\n    }\n}\nexport function observableFromValueWithChangeEvent(owner, value) {\n    if (value instanceof ValueWithChangeEventFromObservable) {\n        return value.observable;\n    }\n    return observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined(owner, fn) {\n    return derivedObservableWithCache(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore, markAsDisposed, toDisposable, trackDisposable } from '../lifecycle.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn) {\n    return new AutorunObserver(new DebugNameData(undefined, undefined, fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges(options, fn) {\n    const store = new DisposableStore();\n    const disposable = autorunHandleChanges({\n        owner: options.owner,\n        debugName: options.debugName,\n        debugReferenceFn: options.debugReferenceFn ?? fn,\n        createEmptyChangeSummary: options.createEmptyChangeSummary,\n        handleChange: options.handleChange,\n    }, (reader, changeSummary) => {\n        store.clear();\n        fn(reader, changeSummary, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn) {\n    const store = new DisposableStore();\n    const disposable = autorunOpts({\n        owner: undefined,\n        debugName: undefined,\n        debugReferenceFn: fn,\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nexport class AutorunObserver {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {\n        this._debugNameData = _debugNameData;\n        this._runFn = _runFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this.state = 2 /* AutorunState.stale */;\n        this.updateCount = 0;\n        this.disposed = false;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleAutorunCreated(this);\n        this._runIfNeeded();\n        trackDisposable(this);\n    }\n    dispose() {\n        this.disposed = true;\n        for (const o of this.dependencies) {\n            o.removeObserver(this);\n        }\n        this.dependencies.clear();\n        markAsDisposed(this);\n    }\n    _runIfNeeded() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        this.state = 3 /* AutorunState.upToDate */;\n        const isDisposed = this.disposed;\n        try {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunTriggered(this);\n                const changeSummary = this.changeSummary;\n                this.changeSummary = this.createChangeSummary?.();\n                this._runFn(this, changeSummary);\n            }\n        }\n        finally {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunFinished(this);\n            }\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    // IObserver implementation\n    beginUpdate() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n        this.updateCount++;\n    }\n    endUpdate() {\n        if (this.updateCount === 1) {\n            do {\n                if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* AutorunState.upToDate */;\n                    for (const d of this.dependencies) {\n                        d.reportChanges();\n                        if (this.state === 2 /* AutorunState.stale */) {\n                            // The other dependencies will refresh on demand\n                            break;\n                        }\n                    }\n                }\n                this._runIfNeeded();\n            } while (this.state !== 3 /* AutorunState.upToDate */);\n        }\n        this.updateCount--;\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            if (shouldReact) {\n                this.state = 2 /* AutorunState.stale */;\n            }\n        }\n    }\n    // IReader implementation\n    readObservable(observable) {\n        // In case the run action disposes the autorun\n        if (this.disposed) {\n            return observable.get();\n        }\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n}\n(function (autorun) {\n    autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { autorun } from './autorun.js';\nimport { observableValue, transaction } from './base.js';\nimport { CancellationError } from '../errors.js';\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise {\n    static fromFn(fn) {\n        return new ObservablePromise(fn());\n    }\n    constructor(promise) {\n        this._value = observableValue(this, undefined);\n        /**\n         * The current state of the promise.\n         * Is `undefined` if the promise didn't resolve yet.\n         */\n        this.promiseResult = this._value;\n        this.promise = promise.then(value => {\n            transaction(tx => {\n                /** @description onPromiseResolved */\n                this._value.set(new PromiseResult(value, undefined), tx);\n            });\n            return value;\n        }, error => {\n            transaction(tx => {\n                /** @description onPromiseRejected */\n                this._value.set(new PromiseResult(undefined, error), tx);\n            });\n            throw error;\n        });\n    }\n}\nexport class PromiseResult {\n    constructor(\n    /**\n     * The value of the resolved promise.\n     * Undefined if the promise rejected.\n     */\n    data, \n    /**\n     * The error in case of a rejected promise.\n     * Undefined if the promise resolved.\n     */\n    error) {\n        this.data = data;\n        this.error = error;\n    }\n}\nexport function waitForState(observable, predicate, isError, cancellationToken) {\n    if (!predicate) {\n        predicate = state => state !== null && state !== undefined;\n    }\n    return new Promise((resolve, reject) => {\n        let isImmediateRun = true;\n        let shouldDispose = false;\n        const stateObs = observable.map(state => {\n            /** @description waitForState.state */\n            return {\n                isFinished: predicate(state),\n                error: isError ? isError(state) : false,\n                state\n            };\n        });\n        const d = autorun(reader => {\n            /** @description waitForState */\n            const { isFinished, error, state } = stateObs.read(reader);\n            if (isFinished || error) {\n                if (isImmediateRun) {\n                    // The variable `d` is not initialized yet\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                if (error) {\n                    reject(error === true ? state : error);\n                }\n                else {\n                    resolve(state);\n                }\n            }\n        });\n        if (cancellationToken) {\n            const dc = cancellationToken.onCancellationRequested(() => {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n            });\n            if (cancellationToken.isCancellationRequested) {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n                return;\n            }\n        }\n        isImmediateRun = false;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BaseObservable, TransactionImpl } from './base.js';\n/**\n * Holds off updating observers until the value is actually read.\n*/\nexport class LazyObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._isUpToDate = true;\n        this._deltas = [];\n        this._updateCounter = 0;\n        this._value = initialValue;\n    }\n    get() {\n        this._update();\n        return this._value;\n    }\n    _update() {\n        if (this._isUpToDate) {\n            return;\n        }\n        this._isUpToDate = true;\n        if (this._deltas.length > 0) {\n            for (const observer of this.observers) {\n                for (const change of this._deltas) {\n                    observer.handleChange(this, change);\n                }\n            }\n            this._deltas.length = 0;\n        }\n        else {\n            for (const observer of this.observers) {\n                observer.handleChange(this, undefined);\n            }\n        }\n    }\n    _beginUpdate() {\n        this._updateCounter++;\n        if (this._updateCounter === 1) {\n            for (const observer of this.observers) {\n                observer.beginUpdate(this);\n            }\n        }\n    }\n    _endUpdate() {\n        this._updateCounter--;\n        if (this._updateCounter === 0) {\n            this._update();\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this._updateCounter > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this._updateCounter > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            this._isUpToDate = false;\n            this._setValue(value);\n            if (change !== undefined) {\n                this._deltas.push(change);\n            }\n            tx.updateObserver({\n                beginUpdate: () => this._beginUpdate(),\n                endUpdate: () => this._endUpdate(),\n                handleChange: (observable, change) => { },\n                handlePossibleChange: (observable) => { },\n            }, this);\n            if (this._updateCounter > 1) {\n                // We already started begin/end update, so we need to manually call handlePossibleChange\n                for (const observer of this.observers) {\n                    observer.handlePossibleChange(this);\n                }\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { ObservableValue } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { LazyObservableValue } from './lazyObservableValue.js';\nexport function observableValueOpts(options, initialValue) {\n    if (options.lazy) {\n        return new LazyObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n    }\n    return new ObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { strictEquals } from '../equals.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\nexport function derived(computeFnOrOwner, computeFn) {\n    if (computeFn !== undefined) {\n        return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals);\n    }\n    return new Derived(new DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, strictEquals);\n}\nexport function derivedWithSetter(owner, computeFn, setter) {\n    return new DerivedWithSetter(new DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals, setter);\n}\nexport function derivedOpts(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, options.equalsFn ?? strictEquals);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? strictEquals);\n}\nexport function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new DisposableStore();\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        return computeFn(r, store);\n    }, undefined, undefined, () => store.dispose(), strictEquals);\n}\nexport function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    let store = undefined;\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        if (!store) {\n            store = new DisposableStore();\n        }\n        else {\n            store.clear();\n        }\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, undefined, () => {\n        if (store) {\n            store.dispose();\n            store = undefined;\n        }\n    }, strictEquals);\n}\nexport class Derived extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        this.updateCount = 0;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = undefined;\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleDerivedCreated(this);\n    }\n    onLastObserverRemoved() {\n        /**\n         * We are not tracking changes anymore, thus we have to assume\n         * that our cache is invalid.\n         */\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        for (const d of this.dependencies) {\n            d.removeObserver(this);\n        }\n        this.dependencies.clear();\n        this._handleLastObserverRemoved?.();\n    }\n    get() {\n        if (this.observers.size === 0) {\n            // Without observers, we don't know when to clean up stuff.\n            // Thus, we don't cache anything to prevent memory leaks.\n            const result = this._computeFn(this, this.createChangeSummary?.());\n            // Clear new dependencies\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                // We might not get a notification for a dependency that changed while it is updating,\n                // thus we also have to ask all our depedencies if they changed in this case.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    for (const d of this.dependencies) {\n                        /** might call {@link handleChange} indirectly, which could make us stale */\n                        d.reportChanges();\n                        if (this.state === 2 /* DerivedState.stale */) {\n                            // The other dependencies will refresh on demand, so early break\n                            break;\n                        }\n                    }\n                }\n                // We called report changes of all dependencies.\n                // If we are still not stale, we can assume to be up to date again.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* DerivedState.upToDate */;\n                }\n                this._recomputeIfNeeded();\n                // In case recomputation changed one of our dependencies, we need to recompute again.\n            } while (this.state !== 3 /* DerivedState.upToDate */);\n            return this.value;\n        }\n    }\n    _recomputeIfNeeded() {\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        const hadValue = this.state !== 0 /* DerivedState.initial */;\n        const oldValue = this.value;\n        this.state = 3 /* DerivedState.upToDate */;\n        const changeSummary = this.changeSummary;\n        this.changeSummary = this.createChangeSummary?.();\n        try {\n            /** might call {@link handleChange} indirectly, which could invalidate us */\n            this.value = this._computeFn(this, changeSummary);\n        }\n        finally {\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n        const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));\n        getLogger()?.handleDerivedRecomputed(this, {\n            oldValue,\n            newValue: this.value,\n            change: undefined,\n            didChange,\n            hadValue,\n        });\n        if (didChange) {\n            for (const r of this.observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    // IObserver Implementation\n    beginUpdate(_observable) {\n        this.updateCount++;\n        const propagateBeginUpdate = this.updateCount === 1;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            // If we propagate begin update, that will already signal a possible change.\n            if (!propagateBeginUpdate) {\n                for (const r of this.observers) {\n                    r.handlePossibleChange(this);\n                }\n            }\n        }\n        if (propagateBeginUpdate) {\n            for (const r of this.observers) {\n                r.beginUpdate(this); // This signals a possible change\n            }\n        }\n    }\n    endUpdate(_observable) {\n        this.updateCount--;\n        if (this.updateCount === 0) {\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        // In all other states, observers already know that we might have changed.\n        if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            for (const r of this.observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n            if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n                this.state = 2 /* DerivedState.stale */;\n                if (wasUpToDate) {\n                    for (const r of this.observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    // IReader Implementation\n    readObservable(observable) {\n        // Subscribe before getting the value to enable caching\n        observable.addObserver(this);\n        /** This might call {@link handleChange} indirectly, which could invalidate us */\n        const value = observable.get();\n        // Which is why we only add the observable to the dependencies now.\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n}\nexport class DerivedWithSetter extends Derived {\n    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {\n        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);\n        this.set = set;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n        this.languageIdCodec = actual.languageIdCodec;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getLineLength() {\n        return this._lastCharOffset - this.firstCharOffset;\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n    toIViewLineTokens() {\n        return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        // flip bytes 0<->3 and 1<->2\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nexport function encodeSemanticTokensDto(semanticTokens) {\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 /* EncodedSemanticTokensType.Full */;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 /* EncodedSemanticTokensType.Delta */;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += (+1 // id\n        + 1 // type\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1 // data length\n            + semanticTokens.data.length);\n    }\n    else {\n        result += (+1 // delta count\n        );\n        result += (+1 // start\n            + 1 // deleteCount\n            + 1 // data length\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { TreeViewsDnDService } from './treeViewsDnd.js';\nexport const ITreeViewsDnDService = createDecorator('treeViewsDndService');\nregisterSingleton(ITreeViewsDnDService, TreeViewsDnDService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport Severity from '../../../base/common/severity.js';\nimport { localize } from '../../../nls.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport var MarkerSeverity;\n(function (MarkerSeverity) {\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {}));\n(function (MarkerSeverity) {\n    function compare(a, b) {\n        return b - a;\n    }\n    MarkerSeverity.compare = compare;\n    const _displayStrings = Object.create(null);\n    _displayStrings[MarkerSeverity.Error] = localize('sev.error', \"Error\");\n    _displayStrings[MarkerSeverity.Warning] = localize('sev.warning', \"Warning\");\n    _displayStrings[MarkerSeverity.Info] = localize('sev.info', \"Info\");\n    function toString(a) {\n        return _displayStrings[a] || '';\n    }\n    MarkerSeverity.toString = toString;\n    function fromSeverity(severity) {\n        switch (severity) {\n            case Severity.Error: return MarkerSeverity.Error;\n            case Severity.Warning: return MarkerSeverity.Warning;\n            case Severity.Info: return MarkerSeverity.Info;\n            case Severity.Ignore: return MarkerSeverity.Hint;\n        }\n    }\n    MarkerSeverity.fromSeverity = fromSeverity;\n    function toSeverity(severity) {\n        switch (severity) {\n            case MarkerSeverity.Error: return Severity.Error;\n            case MarkerSeverity.Warning: return Severity.Warning;\n            case MarkerSeverity.Info: return Severity.Info;\n            case MarkerSeverity.Hint: return Severity.Ignore;\n        }\n    }\n    MarkerSeverity.toSeverity = toSeverity;\n})(MarkerSeverity || (MarkerSeverity = {}));\nexport var IMarkerData;\n(function (IMarkerData) {\n    const emptyString = '';\n    function makeKey(markerData) {\n        return makeKeyOptionalMessage(markerData, true);\n    }\n    IMarkerData.makeKey = makeKey;\n    function makeKeyOptionalMessage(markerData, useMessage) {\n        const result = [emptyString];\n        if (markerData.source) {\n            result.push(markerData.source.replace('¦', '\\\\¦'));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.code) {\n            if (typeof markerData.code === 'string') {\n                result.push(markerData.code.replace('¦', '\\\\¦'));\n            }\n            else {\n                result.push(markerData.code.value.replace('¦', '\\\\¦'));\n            }\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.severity !== undefined && markerData.severity !== null) {\n            result.push(MarkerSeverity.toString(markerData.severity));\n        }\n        else {\n            result.push(emptyString);\n        }\n        // Modifed to not include the message as part of the marker key to work around\n        // https://github.com/microsoft/vscode/issues/77475\n        if (markerData.message && useMessage) {\n            result.push(markerData.message.replace('¦', '\\\\¦'));\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.startLineNumber !== undefined && markerData.startLineNumber !== null) {\n            result.push(markerData.startLineNumber.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.startColumn !== undefined && markerData.startColumn !== null) {\n            result.push(markerData.startColumn.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.endLineNumber !== undefined && markerData.endLineNumber !== null) {\n            result.push(markerData.endLineNumber.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        if (markerData.endColumn !== undefined && markerData.endColumn !== null) {\n            result.push(markerData.endColumn.toString());\n        }\n        else {\n            result.push(emptyString);\n        }\n        result.push(emptyString);\n        return result.join('¦');\n    }\n    IMarkerData.makeKeyOptionalMessage = makeKeyOptionalMessage;\n})(IMarkerData || (IMarkerData = {}));\nexport const IMarkerService = createDecorator('markerService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nexport function _setKeepObserved(keepObserved) {\n    _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n    _derived = derived;\n}\nexport class ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    /**\n     * @sealed\n     * Converts an observable of an observable value into a direct observable of the value.\n    */\n    flatten() {\n        return _derived({\n            owner: undefined,\n            debugName: () => `${this.debugName} (flattened)`,\n        }, (reader) => this.read(reader).read(reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n    /**\n     * Ensures that this observable is observed. This keeps the cache alive.\n     * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n     * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n     */\n    keepObserved(store) {\n        store.add(_keepObserved(this));\n        return this;\n    }\n}\nexport class BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = new Set();\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nexport class TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n        getLogger()?.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        // When this gets called while finish is active, they will still get considered\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this.updatingObservers = null;\n        getLogger()?.handleEndTransaction();\n    }\n}\nexport function observableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new ObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class ObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            getLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        this._value?.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet globalObservableLogger;\nexport function setLogger(logger) {\n    globalObservableLogger = logger;\n}\nexport function getLogger() {\n    return globalObservableLogger;\n}\nexport class ConsoleObservableLogger {\n    constructor() {\n        this.indentation = 0;\n        this.changedObservablesSets = new WeakMap();\n    }\n    textToConsoleArgs(text) {\n        return consoleTextToArgs([\n            normalText(repeat('|  ', this.indentation)),\n            text,\n        ]);\n    }\n    formatInfo(info) {\n        if (!info.hadValue) {\n            return [\n                normalText(` `),\n                styled(formatValue(info.newValue, 60), {\n                    color: 'green',\n                }),\n                normalText(` (initial)`),\n            ];\n        }\n        return info.didChange\n            ? [\n                normalText(` `),\n                styled(formatValue(info.oldValue, 70), {\n                    color: 'red',\n                    strikeThrough: true,\n                }),\n                normalText(` `),\n                styled(formatValue(info.newValue, 60), {\n                    color: 'green',\n                }),\n            ]\n            : [normalText(` (unchanged)`)];\n    }\n    handleObservableChanged(observable, info) {\n        console.log(...this.textToConsoleArgs([\n            formatKind('observable value changed'),\n            styled(observable.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n        ]));\n    }\n    formatChanges(changes) {\n        if (changes.size === 0) {\n            return undefined;\n        }\n        return styled(' (changed deps: ' +\n            [...changes].map((o) => o.debugName).join(', ') +\n            ')', { color: 'gray' });\n    }\n    handleDerivedCreated(derived) {\n        const existingHandleChange = derived.handleChange;\n        this.changedObservablesSets.set(derived, new Set());\n        derived.handleChange = (observable, change) => {\n            this.changedObservablesSets.get(derived).add(observable);\n            return existingHandleChange.apply(derived, [observable, change]);\n        };\n    }\n    handleDerivedRecomputed(derived, info) {\n        const changedObservables = this.changedObservablesSets.get(derived);\n        console.log(...this.textToConsoleArgs([\n            formatKind('derived recomputed'),\n            styled(derived.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n            this.formatChanges(changedObservables),\n            { data: [{ fn: derived._debugNameData.referenceFn ?? derived._computeFn }] }\n        ]));\n        changedObservables.clear();\n    }\n    handleFromEventObservableTriggered(observable, info) {\n        console.log(...this.textToConsoleArgs([\n            formatKind('observable from event triggered'),\n            styled(observable.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n            { data: [{ fn: observable._getValue }] }\n        ]));\n    }\n    handleAutorunCreated(autorun) {\n        const existingHandleChange = autorun.handleChange;\n        this.changedObservablesSets.set(autorun, new Set());\n        autorun.handleChange = (observable, change) => {\n            this.changedObservablesSets.get(autorun).add(observable);\n            return existingHandleChange.apply(autorun, [observable, change]);\n        };\n    }\n    handleAutorunTriggered(autorun) {\n        const changedObservables = this.changedObservablesSets.get(autorun);\n        console.log(...this.textToConsoleArgs([\n            formatKind('autorun'),\n            styled(autorun.debugName, { color: 'BlueViolet' }),\n            this.formatChanges(changedObservables),\n            { data: [{ fn: autorun._debugNameData.referenceFn ?? autorun._runFn }] }\n        ]));\n        changedObservables.clear();\n        this.indentation++;\n    }\n    handleAutorunFinished(autorun) {\n        this.indentation--;\n    }\n    handleBeginTransaction(transaction) {\n        let transactionName = transaction.getDebugName();\n        if (transactionName === undefined) {\n            transactionName = '';\n        }\n        console.log(...this.textToConsoleArgs([\n            formatKind('transaction'),\n            styled(transactionName, { color: 'BlueViolet' }),\n            { data: [{ fn: transaction._fn }] }\n        ]));\n        this.indentation++;\n    }\n    handleEndTransaction() {\n        this.indentation--;\n    }\n}\nfunction consoleTextToArgs(text) {\n    const styles = new Array();\n    const data = [];\n    let firstArg = '';\n    function process(t) {\n        if ('length' in t) {\n            for (const item of t) {\n                if (item) {\n                    process(item);\n                }\n            }\n        }\n        else if ('text' in t) {\n            firstArg += `%c${t.text}`;\n            styles.push(t.style);\n            if (t.data) {\n                data.push(...t.data);\n            }\n        }\n        else if ('data' in t) {\n            data.push(...t.data);\n        }\n    }\n    process(text);\n    const result = [firstArg, ...styles];\n    result.push(...data);\n    return result;\n}\nfunction normalText(text) {\n    return styled(text, { color: 'black' });\n}\nfunction formatKind(kind) {\n    return styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });\n}\nfunction styled(text, options = {\n    color: 'black',\n}) {\n    function objToCss(styleObj) {\n        return Object.entries(styleObj).reduce((styleString, [propName, propValue]) => {\n            return `${styleString}${propName}:${propValue};`;\n        }, '');\n    }\n    const style = {\n        color: options.color,\n    };\n    if (options.strikeThrough) {\n        style['text-decoration'] = 'line-through';\n    }\n    if (options.bold) {\n        style['font-weight'] = 'bold';\n    }\n    return {\n        text,\n        style: objToCss(style),\n    };\n}\nfunction formatValue(value, availableLen) {\n    switch (typeof value) {\n        case 'number':\n            return '' + value;\n        case 'string':\n            if (value.length + 2 <= availableLen) {\n                return `\"${value}\"`;\n            }\n            return `\"${value.substr(0, availableLen - 7)}\"+...`;\n        case 'boolean':\n            return value ? 'true' : 'false';\n        case 'undefined':\n            return 'undefined';\n        case 'object':\n            if (value === null) {\n                return 'null';\n            }\n            if (Array.isArray(value)) {\n                return formatArray(value, availableLen);\n            }\n            return formatObject(value, availableLen);\n        case 'symbol':\n            return value.toString();\n        case 'function':\n            return `[[Function${value.name ? ' ' + value.name : ''}]]`;\n        default:\n            return '' + value;\n    }\n}\nfunction formatArray(value, availableLen) {\n    let result = '[ ';\n    let first = true;\n    for (const val of value) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${formatValue(val, availableLen - result.length)}`;\n    }\n    result += ' ]';\n    return result;\n}\nfunction formatObject(value, availableLen) {\n    let result = '{ ';\n    let first = true;\n    for (const [key, val] of Object.entries(value)) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${key}: ${formatValue(val, availableLen - result.length)}`;\n    }\n    result += ' }';\n    return result;\n}\nfunction repeat(str, count) {\n    let result = '';\n    for (let i = 1; i <= count; i++) {\n        result += str;\n    }\n    return result;\n}\nfunction padStr(str, length) {\n    while (str.length < length) {\n        str += ' ';\n    }\n    return str;\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextModelService = createDecorator('textModelService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService } from '../../../platform/log/common/log.js';\nimport { SemanticTokensProviderStyling } from './semanticTokensProviderStyling.js';\nimport { ISemanticTokensStylingService } from './semanticTokensStyling.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nlet SemanticTokensStylingService = class SemanticTokensStylingService extends Disposable {\n    constructor(_themeService, _logService, _languageService) {\n        super();\n        this._themeService = _themeService;\n        this._logService = _logService;\n        this._languageService = _languageService;\n        this._caches = new WeakMap();\n        this._register(this._themeService.onDidColorThemeChange(() => {\n            this._caches = new WeakMap();\n        }));\n    }\n    getStyling(provider) {\n        if (!this._caches.has(provider)) {\n            this._caches.set(provider, new SemanticTokensProviderStyling(provider.getLegend(), this._themeService, this._languageService, this._logService));\n        }\n        return this._caches.get(provider);\n    }\n};\nSemanticTokensStylingService = __decorate([\n    __param(0, IThemeService),\n    __param(1, ILogService),\n    __param(2, ILanguageService)\n], SemanticTokensStylingService);\nexport { SemanticTokensStylingService };\nregisterSingleton(ISemanticTokensStylingService, SemanticTokensStylingService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IUndoRedoService = createDecorator('undoRedoService');\nexport class ResourceEditStackSnapshot {\n    constructor(resource, elements) {\n        this.resource = resource;\n        this.elements = elements;\n    }\n}\nexport class UndoRedoGroup {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoGroup._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoGroup(); }\n}\nexport class UndoRedoSource {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoSource._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoSource(); }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelService_1;\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this.model = model;\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    static { ModelService_1 = this; }\n    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }\n    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._undoRedoService = _undoRedoService;\n        this._instantiationService = _instantiationService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));\n        this._updateModelOptions(undefined);\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = 'tabSize';\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = Math.max(parsedIndentSize, 1);\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {\n        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions(e) {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {\n                continue; // perf: skip if this model is not affected by configuration change\n            }\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);\n        const model = this._instantiationService.createInstance(TextModel, value, languageIdOrSelection, options, resource);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1Computer = this._getSHA1Computer();\n            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)\n                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1\n                : false);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        const sha1Computer = this._getSHA1Computer();\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {\n            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n    _getSHA1Computer() {\n        return new DefaultModelSHA1Computer();\n    }\n};\nModelService = ModelService_1 = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IUndoRedoService),\n    __param(3, IInstantiationService)\n], ModelService);\nexport { ModelService };\nexport class DefaultModelSHA1Computer {\n    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine\n    canComputeSHA1(model) {\n        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);\n    }\n    computeSHA1(model) {\n        // compute the sha1\n        const shaComputer = new StringSHA1();\n        const snapshot = model.createSnapshot();\n        let text;\n        while ((text = snapshot.read())) {\n            shaComputer.update(text);\n        }\n        return shaComputer.digest();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class DebugNameData {\n    constructor(owner, debugNameSource, referenceFn) {\n        this.owner = owner;\n        this.debugNameSource = debugNameSource;\n        this.referenceFn = referenceFn;\n    }\n    getDebugName(target) {\n        return getDebugName(target, this);\n    }\n}\nconst countPerName = new Map();\nconst cachedDebugName = new WeakMap();\nexport function getDebugName(target, data) {\n    const cached = cachedDebugName.get(target);\n    if (cached) {\n        return cached;\n    }\n    const dbgName = computeDebugName(target, data);\n    if (dbgName) {\n        let count = countPerName.get(dbgName) ?? 0;\n        count++;\n        countPerName.set(dbgName, count);\n        const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n        cachedDebugName.set(target, result);\n        return result;\n    }\n    return undefined;\n}\nfunction computeDebugName(self, data) {\n    const cached = cachedDebugName.get(self);\n    if (cached) {\n        return cached;\n    }\n    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n    let result;\n    const debugNameSource = data.debugNameSource;\n    if (debugNameSource !== undefined) {\n        if (typeof debugNameSource === 'function') {\n            result = debugNameSource();\n            if (result !== undefined) {\n                return ownerStr + result;\n            }\n        }\n        else {\n            return ownerStr + debugNameSource;\n        }\n    }\n    const referenceFn = data.referenceFn;\n    if (referenceFn !== undefined) {\n        result = getFunctionName(referenceFn);\n        if (result !== undefined) {\n            return ownerStr + result;\n        }\n    }\n    if (data.owner !== undefined) {\n        const key = findKey(data.owner, self);\n        if (key !== undefined) {\n            return ownerStr + key;\n        }\n    }\n    return undefined;\n}\nfunction findKey(obj, value) {\n    for (const key in obj) {\n        if (obj[key] === value) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst countPerClassName = new Map();\nconst ownerId = new WeakMap();\nfunction formatOwner(owner) {\n    const id = ownerId.get(owner);\n    if (id) {\n        return id;\n    }\n    const className = getClassName(owner);\n    let count = countPerClassName.get(className) ?? 0;\n    count++;\n    countPerClassName.set(className, count);\n    const result = count === 1 ? className : `${className}#${count}`;\n    ownerId.set(owner, result);\n    return result;\n}\nfunction getClassName(obj) {\n    const ctor = obj.constructor;\n    if (ctor) {\n        return ctor.name;\n    }\n    return 'Object';\n}\nexport function getFunctionName(fn) {\n    const fnSrc = fn.toString();\n    // Pattern: /** @description ... */\n    const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n    const match = regexp.exec(fnSrc);\n    const result = match ? match[1] : undefined;\n    return result?.trim();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t'; }\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t'; }\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\nimport { createBracketOrRegExp } from './richEditBrackets.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n    getBracketRegExp(options) {\n        const brackets = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);\n        return createBracketOrRegExp(brackets, options);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return entries?.getResolvedConfiguration() || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n        let offset = 0;\n        let fullText = '';\n        const tokens = new Array();\n        for (const { text, metadata } of data) {\n            tokens.push(offset + text.length, metadata);\n            offset += text.length;\n            fullText += text;\n        }\n        return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this.languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n        const startOffset = this.getStartOffset(tokenIndex);\n        const endOffset = this.getEndOffset(tokenIndex);\n        const text = this._text.substring(startOffset, endOffset);\n        return text;\n    }\n    forEach(callback) {\n        const tokenCount = this.getCount();\n        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this.languageIdCodec = source.languageIdCodec;\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n    getTokenText(tokenIndex) {\n        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n        let text = this._source.getTokenText(adjustedTokenIndex);\n        if (tokenStartOffset < this._startOffset) {\n            text = text.substring(this._startOffset - tokenStartOffset);\n        }\n        if (tokenEndOffset > this._endOffset) {\n            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n        }\n        return text;\n    }\n    forEach(callback) {\n        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n    const lineNumber = position.lineNumber;\n    if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        return undefined;\n    }\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n    return tokenType;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Codicon } from './codicons.js';\nexport var ThemeColor;\n(function (ThemeColor) {\n    function isThemeColor(obj) {\n        return obj && typeof obj === 'object' && typeof obj.id === 'string';\n    }\n    ThemeColor.isThemeColor = isThemeColor;\n})(ThemeColor || (ThemeColor = {}));\nexport var ThemeIcon;\n(function (ThemeIcon) {\n    ThemeIcon.iconNameSegment = '[A-Za-z0-9]+';\n    ThemeIcon.iconNameExpression = '[A-Za-z0-9-]+';\n    ThemeIcon.iconModifierExpression = '~[A-Za-z]+';\n    ThemeIcon.iconNameCharacter = '[A-Za-z0-9~-]';\n    const ThemeIconIdRegex = new RegExp(`^(${ThemeIcon.iconNameExpression})(${ThemeIcon.iconModifierExpression})?$`);\n    function asClassNameArray(icon) {\n        const match = ThemeIconIdRegex.exec(icon.id);\n        if (!match) {\n            return asClassNameArray(Codicon.error);\n        }\n        const [, id, modifier] = match;\n        const classNames = ['codicon', 'codicon-' + id];\n        if (modifier) {\n            classNames.push('codicon-modifier-' + modifier.substring(1));\n        }\n        return classNames;\n    }\n    ThemeIcon.asClassNameArray = asClassNameArray;\n    function asClassName(icon) {\n        return asClassNameArray(icon).join(' ');\n    }\n    ThemeIcon.asClassName = asClassName;\n    function asCSSSelector(icon) {\n        return '.' + asClassNameArray(icon).join('.');\n    }\n    ThemeIcon.asCSSSelector = asCSSSelector;\n    function isThemeIcon(obj) {\n        return obj && typeof obj === 'object' && typeof obj.id === 'string' && (typeof obj.color === 'undefined' || ThemeColor.isThemeColor(obj.color));\n    }\n    ThemeIcon.isThemeIcon = isThemeIcon;\n    const _regexFromString = new RegExp(`^\\\\$\\\\((${ThemeIcon.iconNameExpression}(?:${ThemeIcon.iconModifierExpression})?)\\\\)$`);\n    function fromString(str) {\n        const match = _regexFromString.exec(str);\n        if (!match) {\n            return undefined;\n        }\n        const [, name] = match;\n        return { id: name };\n    }\n    ThemeIcon.fromString = fromString;\n    function fromId(id) {\n        return { id };\n    }\n    ThemeIcon.fromId = fromId;\n    function modify(icon, modifier) {\n        let id = icon.id;\n        const tildeIndex = id.lastIndexOf('~');\n        if (tildeIndex !== -1) {\n            id = id.substring(0, tildeIndex);\n        }\n        if (modifier) {\n            id = `${id}~${modifier}`;\n        }\n        return { id };\n    }\n    ThemeIcon.modify = modify;\n    function getModifier(icon) {\n        const tildeIndex = icon.id.lastIndexOf('~');\n        if (tildeIndex !== -1) {\n            return icon.id.substring(tildeIndex + 1);\n        }\n        return undefined;\n    }\n    ThemeIcon.getModifier = getModifier;\n    function isEqual(ti1, ti2) {\n        return ti1.id === ti2.id && ti1.color?.id === ti2.color?.id;\n    }\n    ThemeIcon.isEqual = isEqual;\n})(ThemeIcon || (ThemeIcon = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function clamp(value, min, max) {\n    return Math.min(Math.max(value, min), max);\n}\nexport class MovingAverage {\n    constructor() {\n        this._n = 1;\n        this._val = 0;\n    }\n    update(value) {\n        this._val = this._val + (value - this._val) / this._n;\n        this._n += 1;\n        return this._val;\n    }\n    get value() {\n        return this._val;\n    }\n}\nexport class SlidingWindowAverage {\n    constructor(size) {\n        this._n = 0;\n        this._val = 0;\n        this._values = [];\n        this._index = 0;\n        this._sum = 0;\n        this._values = new Array(size);\n        this._values.fill(0, 0, size);\n    }\n    update(value) {\n        const oldValue = this._values[this._index];\n        this._values[this._index] = value;\n        this._index = (this._index + 1) % this._values.length;\n        this._sum -= oldValue;\n        this._sum += value;\n        if (this._n < this._values.length) {\n            this._n += 1;\n        }\n        this._val = this._sum / this._n;\n        return this._val;\n    }\n    get value() {\n        return this._val;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from './strings.js';\nvar Severity;\n(function (Severity) {\n    Severity[Severity[\"Ignore\"] = 0] = \"Ignore\";\n    Severity[Severity[\"Info\"] = 1] = \"Info\";\n    Severity[Severity[\"Warning\"] = 2] = \"Warning\";\n    Severity[Severity[\"Error\"] = 3] = \"Error\";\n})(Severity || (Severity = {}));\n(function (Severity) {\n    const _error = 'error';\n    const _warning = 'warning';\n    const _warn = 'warn';\n    const _info = 'info';\n    const _ignore = 'ignore';\n    /**\n     * Parses 'error', 'warning', 'warn', 'info' in call casings\n     * and falls back to ignore.\n     */\n    function fromValue(value) {\n        if (!value) {\n            return Severity.Ignore;\n        }\n        if (strings.equalsIgnoreCase(_error, value)) {\n            return Severity.Error;\n        }\n        if (strings.equalsIgnoreCase(_warning, value) || strings.equalsIgnoreCase(_warn, value)) {\n            return Severity.Warning;\n        }\n        if (strings.equalsIgnoreCase(_info, value)) {\n            return Severity.Info;\n        }\n        return Severity.Ignore;\n    }\n    Severity.fromValue = fromValue;\n    function toString(severity) {\n        switch (severity) {\n            case Severity.Error: return _error;\n            case Severity.Warning: return _warning;\n            case Severity.Info: return _info;\n            default: return _ignore;\n        }\n    }\n    Severity.toString = toString;\n})(Severity || (Severity = {}));\nexport default Severity;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        // selector targets a notebook -> use the notebook uri instead\n        // of the \"normal\" document uri.\n        if (notebookType && candidateNotebookUri) {\n            candidateUri = candidateNotebookUri;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (notebookType) {\n            if (notebookType === candidateNotebookType) {\n                ret = 10;\n            }\n            else if (notebookType === '*' && candidateNotebookType !== undefined) {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = { ...pattern, base: normalize(pattern.base) };\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Schemas } from '../../../base/common/network.js';\nimport { DataUri } from '../../../base/common/resources.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { FileKind } from '../../../platform/files/common/files.js';\nimport { ThemeIcon } from '../../../base/common/themables.js';\nconst fileIconDirectoryRegex = /(?:\\/|^)(?:([^\\/]+)\\/)?([^\\/]+)$/;\nexport function getIconClasses(modelService, languageService, resource, fileKind, icon) {\n    if (ThemeIcon.isThemeIcon(icon)) {\n        return [`codicon-${icon.id}`, 'predefined-file-icon'];\n    }\n    if (URI.isUri(icon)) {\n        return [];\n    }\n    // we always set these base classes even if we do not have a path\n    const classes = fileKind === FileKind.ROOT_FOLDER ? ['rootfolder-icon'] : fileKind === FileKind.FOLDER ? ['folder-icon'] : ['file-icon'];\n    if (resource) {\n        // Get the path and name of the resource. For data-URIs, we need to parse specially\n        let name;\n        if (resource.scheme === Schemas.data) {\n            const metadata = DataUri.parseMetaData(resource);\n            name = metadata.get(DataUri.META_DATA_LABEL);\n        }\n        else {\n            const match = resource.path.match(fileIconDirectoryRegex);\n            if (match) {\n                name = cssEscape(match[2].toLowerCase());\n                if (match[1]) {\n                    classes.push(`${cssEscape(match[1].toLowerCase())}-name-dir-icon`); // parent directory\n                }\n            }\n            else {\n                name = cssEscape(resource.authority.toLowerCase());\n            }\n        }\n        // Root Folders\n        if (fileKind === FileKind.ROOT_FOLDER) {\n            classes.push(`${name}-root-name-folder-icon`);\n        }\n        // Folders\n        else if (fileKind === FileKind.FOLDER) {\n            classes.push(`${name}-name-folder-icon`);\n        }\n        // Files\n        else {\n            // Name & Extension(s)\n            if (name) {\n                classes.push(`${name}-name-file-icon`);\n                classes.push(`name-file-icon`); // extra segment to increase file-name score\n                // Avoid doing an explosive combination of extensions for very long filenames\n                // (most file systems do not allow files > 255 length) with lots of `.` characters\n                // https://github.com/microsoft/vscode/issues/116199\n                if (name.length <= 255) {\n                    const dotSegments = name.split('.');\n                    for (let i = 1; i < dotSegments.length; i++) {\n                        classes.push(`${dotSegments.slice(i).join('.')}-ext-file-icon`); // add each combination of all found extensions if more than one\n                    }\n                }\n                classes.push(`ext-file-icon`); // extra segment to increase file-ext score\n            }\n            // Detected Mode\n            const detectedLanguageId = detectLanguageId(modelService, languageService, resource);\n            if (detectedLanguageId) {\n                classes.push(`${cssEscape(detectedLanguageId)}-lang-file-icon`);\n            }\n        }\n    }\n    return classes;\n}\nfunction detectLanguageId(modelService, languageService, resource) {\n    if (!resource) {\n        return null; // we need a resource at least\n    }\n    let languageId = null;\n    // Data URI: check for encoded metadata\n    if (resource.scheme === Schemas.data) {\n        const metadata = DataUri.parseMetaData(resource);\n        const mime = metadata.get(DataUri.META_DATA_MIME);\n        if (mime) {\n            languageId = languageService.getLanguageIdByMimeType(mime);\n        }\n    }\n    // Any other URI: check for model if existing\n    else {\n        const model = modelService.getModel(resource);\n        if (model) {\n            languageId = model.getLanguageId();\n        }\n    }\n    // only take if the language id is specific (aka no just plain text)\n    if (languageId && languageId !== PLAINTEXT_LANGUAGE_ID) {\n        return languageId;\n    }\n    // otherwise fallback to path based detection\n    return languageService.guessLanguageIdByFilepathOrFirstLine(resource);\n}\nfunction cssEscape(str) {\n    return str.replace(/[\\s]/g, '/'); // HTML class names can not contain certain whitespace characters (https://dom.spec.whatwg.org/#interface-domtokenlist), use / instead, which doesn't exist in file names.\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IMarkerDecorationsService = createDecorator('markerDecorationsService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nclass MatchCandidate {\n    constructor(uri, languageId, notebookUri, notebookType, recursive) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.notebookUri = notebookUri;\n        this.notebookType = notebookType;\n        this.recursive = recursive;\n    }\n    equals(other) {\n        return this.notebookType === other.notebookType\n            && this.languageId === other.languageId\n            && this.uri.toString() === other.uri.toString()\n            && this.notebookUri?.toString() === other.notebookUri?.toString()\n            && this.recursive === other.recursive;\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookInfoResolver) {\n        this._notebookInfoResolver = _notebookInfoResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model, false);\n        const result = [];\n        // from registry\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model, recursive = false) {\n        const result = [];\n        this._orderedForEach(model, recursive, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, false, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, recursive, callback) {\n        this._updateScores(model, recursive);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model, recursive) {\n        const notebookInfo = this._notebookInfoResolver?.(model.uri);\n        // use the uri (scheme, pattern) of the notebook info iff we have one\n        // otherwise it's the model's/document's uri\n        const candidate = notebookInfo\n            ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type, recursive)\n            : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined, recursive);\n        if (this._lastCandidate?.equals(candidate)) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (const entry of this._entries) {\n            entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                if (recursive) {\n                    entry._score = 0;\n                }\n                else {\n                    // support for one exclusive selector that overwrites\n                    // any other selector\n                    for (const entry of this._entries) {\n                        entry._score = 0;\n                    }\n                    entry._score = 1000;\n                    break;\n                }\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        // De-prioritize built-in providers\n        if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {\n            return 1;\n        }\n        else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {\n            return -1;\n        }\n        if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nfunction isBuiltinSelector(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    if (Array.isArray(selector)) {\n        return selector.some(isBuiltinSelector);\n    }\n    return Boolean(selector.isBuiltin);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageFeatureRegistry } from '../languageFeatureRegistry.js';\nimport { ILanguageFeaturesService } from './languageFeatures.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nexport class LanguageFeaturesService {\n    constructor() {\n        this.referenceProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.renameProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.newSymbolNamesProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.codeActionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.definitionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.typeDefinitionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.declarationProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.implementationProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentSymbolProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.inlayHintsProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.colorProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.codeLensProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentRangeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.onTypeFormattingEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.signatureHelpProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.hoverProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentHighlightProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.multiDocumentHighlightProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.selectionRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.foldingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.linkProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.inlineCompletionsProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.inlineEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.completionProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.linkedEditingRangeProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentRangeSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentSemanticTokensProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentDropEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n        this.documentPasteEditProvider = new LanguageFeatureRegistry(this._score.bind(this));\n    }\n    _score(uri) {\n        return this._notebookTypeResolver?.(uri);\n    }\n}\nregisterSingleton(ILanguageFeaturesService, LanguageFeaturesService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LanguagesRegistry } from './languagesRegistry.js';\nimport { firstOrDefault } from '../../../base/common/arrays.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { observableFromEvent } from '../../../base/common/observable.js';\nexport class LanguageService extends Disposable {\n    static { this.instanceCount = 0; }\n    constructor(warnOnOverwrite = false) {\n        super();\n        this._onDidRequestBasicLanguageFeatures = this._register(new Emitter());\n        this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event;\n        this._onDidRequestRichLanguageFeatures = this._register(new Emitter());\n        this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event;\n        this._onDidChange = this._register(new Emitter({ leakWarningThreshold: 200 /* https://github.com/microsoft/vscode/issues/119968 */ }));\n        this.onDidChange = this._onDidChange.event;\n        this._requestedBasicLanguages = new Set();\n        this._requestedRichLanguages = new Set();\n        LanguageService.instanceCount++;\n        this._registry = this._register(new LanguagesRegistry(true, warnOnOverwrite));\n        this.languageIdCodec = this._registry.languageIdCodec;\n        this._register(this._registry.onDidChange(() => this._onDidChange.fire()));\n    }\n    dispose() {\n        LanguageService.instanceCount--;\n        super.dispose();\n    }\n    isRegisteredLanguageId(languageId) {\n        return this._registry.isRegisteredLanguageId(languageId);\n    }\n    getLanguageIdByLanguageName(languageName) {\n        return this._registry.getLanguageIdByLanguageName(languageName);\n    }\n    getLanguageIdByMimeType(mimeType) {\n        return this._registry.getLanguageIdByMimeType(mimeType);\n    }\n    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n        const languageIds = this._registry.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n        return firstOrDefault(languageIds, null);\n    }\n    createById(languageId) {\n        return new LanguageSelection(this.onDidChange, () => {\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    createByFilepathOrFirstLine(resource, firstLine) {\n        return new LanguageSelection(this.onDidChange, () => {\n            const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    _createAndGetLanguageIdentifier(languageId) {\n        if (!languageId || !this.isRegisteredLanguageId(languageId)) {\n            // Fall back to plain text if language is unknown\n            languageId = PLAINTEXT_LANGUAGE_ID;\n        }\n        return languageId;\n    }\n    requestBasicLanguageFeatures(languageId) {\n        if (!this._requestedBasicLanguages.has(languageId)) {\n            this._requestedBasicLanguages.add(languageId);\n            this._onDidRequestBasicLanguageFeatures.fire(languageId);\n        }\n    }\n    requestRichLanguageFeatures(languageId) {\n        if (!this._requestedRichLanguages.has(languageId)) {\n            this._requestedRichLanguages.add(languageId);\n            // Ensure basic features are requested\n            this.requestBasicLanguageFeatures(languageId);\n            // Ensure tokenizers are created\n            TokenizationRegistry.getOrCreate(languageId);\n            this._onDidRequestRichLanguageFeatures.fire(languageId);\n        }\n    }\n}\nclass LanguageSelection {\n    constructor(onDidChangeLanguages, selector) {\n        this._value = observableFromEvent(this, onDidChangeLanguages, () => selector());\n        this.onDidChange = Event.fromObservable(this._value);\n    }\n    get languageId() {\n        return this._value.get();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","import { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IEnvironmentService = createDecorator('environmentService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function diffSets(before, after) {\n    const removed = [];\n    const added = [];\n    for (const element of before) {\n        if (!after.has(element)) {\n            removed.push(element);\n        }\n    }\n    for (const element of after) {\n        if (!before.has(element)) {\n            added.push(element);\n        }\n    }\n    return { removed, added };\n}\n/**\n * Computes the intersection of two sets.\n *\n * @param setA - The first set.\n * @param setB - The second iterable.\n * @returns A new set containing the elements that are in both `setA` and `setB`.\n */\nexport function intersection(setA, setB) {\n    const result = new Set();\n    for (const elem of setB) {\n        if (setA.has(elem)) {\n            result.add(elem);\n        }\n    }\n    return result;\n}\n","//#endregion\n//#region Utilities\nexport var FileKind;\n(function (FileKind) {\n    FileKind[FileKind[\"FILE\"] = 0] = \"FILE\";\n    FileKind[FileKind[\"FOLDER\"] = 1] = \"FOLDER\";\n    FileKind[FileKind[\"ROOT_FOLDER\"] = 2] = \"ROOT_FOLDER\";\n})(FileKind || (FileKind = {}));\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { IMarkerService, MarkerSeverity } from '../../../platform/markers/common/markers.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { OverviewRulerLane } from '../model.js';\nimport { themeColorFromId } from '../../../platform/theme/common/themeService.js';\nimport { overviewRulerWarning, overviewRulerInfo, overviewRulerError } from '../core/editorColorRegistry.js';\nimport { IModelService } from './model.js';\nimport { Range } from '../core/range.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { minimapInfo, minimapWarning, minimapError } from '../../../platform/theme/common/colorRegistry.js';\nimport { BidirectionalMap, ResourceMap } from '../../../base/common/map.js';\nimport { diffSets } from '../../../base/common/collections.js';\nlet MarkerDecorationsService = class MarkerDecorationsService extends Disposable {\n    constructor(modelService, _markerService) {\n        super();\n        this._markerService = _markerService;\n        this._onDidChangeMarker = this._register(new Emitter());\n        this._markerDecorations = new ResourceMap();\n        modelService.getModels().forEach(model => this._onModelAdded(model));\n        this._register(modelService.onModelAdded(this._onModelAdded, this));\n        this._register(modelService.onModelRemoved(this._onModelRemoved, this));\n        this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));\n    }\n    dispose() {\n        super.dispose();\n        this._markerDecorations.forEach(value => value.dispose());\n        this._markerDecorations.clear();\n    }\n    getMarker(uri, decoration) {\n        const markerDecorations = this._markerDecorations.get(uri);\n        return markerDecorations ? (markerDecorations.getMarker(decoration) || null) : null;\n    }\n    _handleMarkerChange(changedResources) {\n        changedResources.forEach((resource) => {\n            const markerDecorations = this._markerDecorations.get(resource);\n            if (markerDecorations) {\n                this._updateDecorations(markerDecorations);\n            }\n        });\n    }\n    _onModelAdded(model) {\n        const markerDecorations = new MarkerDecorations(model);\n        this._markerDecorations.set(model.uri, markerDecorations);\n        this._updateDecorations(markerDecorations);\n    }\n    _onModelRemoved(model) {\n        const markerDecorations = this._markerDecorations.get(model.uri);\n        if (markerDecorations) {\n            markerDecorations.dispose();\n            this._markerDecorations.delete(model.uri);\n        }\n        // clean up markers for internal, transient models\n        if (model.uri.scheme === Schemas.inMemory\n            || model.uri.scheme === Schemas.internal\n            || model.uri.scheme === Schemas.vscode) {\n            this._markerService?.read({ resource: model.uri }).map(marker => marker.owner).forEach(owner => this._markerService.remove(owner, [model.uri]));\n        }\n    }\n    _updateDecorations(markerDecorations) {\n        // Limit to the first 500 errors/warnings\n        const markers = this._markerService.read({ resource: markerDecorations.model.uri, take: 500 });\n        if (markerDecorations.update(markers)) {\n            this._onDidChangeMarker.fire(markerDecorations.model);\n        }\n    }\n};\nMarkerDecorationsService = __decorate([\n    __param(0, IModelService),\n    __param(1, IMarkerService)\n], MarkerDecorationsService);\nexport { MarkerDecorationsService };\nclass MarkerDecorations extends Disposable {\n    constructor(model) {\n        super();\n        this.model = model;\n        this._map = new BidirectionalMap();\n        this._register(toDisposable(() => {\n            this.model.deltaDecorations([...this._map.values()], []);\n            this._map.clear();\n        }));\n    }\n    update(markers) {\n        // We use the fact that marker instances are not recreated when different owners\n        // update. So we can compare references to find out what changed since the last update.\n        const { added, removed } = diffSets(new Set(this._map.keys()), new Set(markers));\n        if (added.length === 0 && removed.length === 0) {\n            return false;\n        }\n        const oldIds = removed.map(marker => this._map.get(marker));\n        const newDecorations = added.map(marker => {\n            return {\n                range: this._createDecorationRange(this.model, marker),\n                options: this._createDecorationOption(marker)\n            };\n        });\n        const ids = this.model.deltaDecorations(oldIds, newDecorations);\n        for (const removedMarker of removed) {\n            this._map.delete(removedMarker);\n        }\n        for (let index = 0; index < ids.length; index++) {\n            this._map.set(added[index], ids[index]);\n        }\n        return true;\n    }\n    getMarker(decoration) {\n        return this._map.getKey(decoration.id);\n    }\n    _createDecorationRange(model, rawMarker) {\n        let ret = Range.lift(rawMarker);\n        if (rawMarker.severity === MarkerSeverity.Hint && !this._hasMarkerTag(rawMarker, 1 /* MarkerTag.Unnecessary */) && !this._hasMarkerTag(rawMarker, 2 /* MarkerTag.Deprecated */)) {\n            // * never render hints on multiple lines\n            // * make enough space for three dots\n            ret = ret.setEndPosition(ret.startLineNumber, ret.startColumn + 2);\n        }\n        ret = model.validateRange(ret);\n        if (ret.isEmpty()) {\n            const maxColumn = model.getLineLastNonWhitespaceColumn(ret.startLineNumber) ||\n                model.getLineMaxColumn(ret.startLineNumber);\n            if (maxColumn === 1 || ret.endColumn >= maxColumn) {\n                // empty line or behind eol\n                // keep the range as is, it will be rendered 1ch wide\n                return ret;\n            }\n            const word = model.getWordAtPosition(ret.getStartPosition());\n            if (word) {\n                ret = new Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);\n            }\n        }\n        else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {\n            const minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);\n            if (minColumn < ret.endColumn) {\n                ret = new Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);\n                rawMarker.startColumn = minColumn;\n            }\n        }\n        return ret;\n    }\n    _createDecorationOption(marker) {\n        let className;\n        let color = undefined;\n        let zIndex;\n        let inlineClassName = undefined;\n        let minimap;\n        switch (marker.severity) {\n            case MarkerSeverity.Hint:\n                if (this._hasMarkerTag(marker, 2 /* MarkerTag.Deprecated */)) {\n                    className = undefined;\n                }\n                else if (this._hasMarkerTag(marker, 1 /* MarkerTag.Unnecessary */)) {\n                    className = \"squiggly-unnecessary\" /* ClassName.EditorUnnecessaryDecoration */;\n                }\n                else {\n                    className = \"squiggly-hint\" /* ClassName.EditorHintDecoration */;\n                }\n                zIndex = 0;\n                break;\n            case MarkerSeverity.Info:\n                className = \"squiggly-info\" /* ClassName.EditorInfoDecoration */;\n                color = themeColorFromId(overviewRulerInfo);\n                zIndex = 10;\n                minimap = {\n                    color: themeColorFromId(minimapInfo),\n                    position: 1 /* MinimapPosition.Inline */\n                };\n                break;\n            case MarkerSeverity.Warning:\n                className = \"squiggly-warning\" /* ClassName.EditorWarningDecoration */;\n                color = themeColorFromId(overviewRulerWarning);\n                zIndex = 20;\n                minimap = {\n                    color: themeColorFromId(minimapWarning),\n                    position: 1 /* MinimapPosition.Inline */\n                };\n                break;\n            case MarkerSeverity.Error:\n            default:\n                className = \"squiggly-error\" /* ClassName.EditorErrorDecoration */;\n                color = themeColorFromId(overviewRulerError);\n                zIndex = 30;\n                minimap = {\n                    color: themeColorFromId(minimapError),\n                    position: 1 /* MinimapPosition.Inline */\n                };\n                break;\n        }\n        if (marker.tags) {\n            if (marker.tags.indexOf(1 /* MarkerTag.Unnecessary */) !== -1) {\n                inlineClassName = \"squiggly-inline-unnecessary\" /* ClassName.EditorUnnecessaryInlineDecoration */;\n            }\n            if (marker.tags.indexOf(2 /* MarkerTag.Deprecated */) !== -1) {\n                inlineClassName = \"squiggly-inline-deprecated\" /* ClassName.EditorDeprecatedInlineDecoration */;\n            }\n        }\n        return {\n            description: 'marker-decoration',\n            stickiness: 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */,\n            className,\n            showIfCollapsed: true,\n            overviewRuler: {\n                color,\n                position: OverviewRulerLane.Right\n            },\n            minimap,\n            zIndex,\n            inlineClassName,\n        };\n    }\n    _hasMarkerTag(marker, tag) {\n        if (marker.tags) {\n            return marker.tags.indexOf(tag) >= 0;\n        }\n        return false;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const IEditorWorkerService = createDecorator('editorWorkerService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n"],"names":["RichEditBracket","constructor","languageId","index","open","close","forwardRegex","reversedRegex","this","_richEditBracketBrand","undefined","_openSet","_toSet","_closeSet","isOpen","text","has","isClose","arr","result","Set","element","add","RichEditBrackets","_brackets","_richEditBracketsBrand","brackets","N","length","map","b","toLowerCase","group","i","areOverlapping","a","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","Math","min","oldG","max","j","g","currentOpen","currentClose","push","groupFuzzyBrackets","currentIndex","pieces","concat","len","collectSuperstrings","unique","sort","lengthcmp","reverse","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","bracket","getRegexForBrackets","getReversedRegexForBrackets","textIsBracket","textIsOpenBracket","maxBracketLength","str","dest","indexOf","seen","prepareBracketForRegExp","insertWordBoundaries","test","options","regexStr","join","lastInput","lastOutput","Uint16Array","offset","charCodeAt","decode","BracketsUtils","_findPrevBracketInText","reversedBracketRegex","lineNumber","reversedText","m","match","matchOffset","matchLength","absoluteMatchOffset","findPrevBracketInRange","lineText","startOffset","endOffset","reversedSubstr","substring","findNextBracketInText","bracketRegex","findNextBracketInRange","substr","escapeNewLine","replace","TextChange","oldLength","oldText","oldEnd","oldPosition","newLength","newText","newEnd","newPosition","toString","_writeStringSize","_writeString","_readString","writeSize","write","read","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","_acceptCurr","_acceptPrev","e1","e2","_splitCurr","_splitPrev","mergePrev","mergeCurr","merged","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","postText","edits","resultLen","prev","curr","strictEquals","itemsEquals","itemEquals","equals","equalsIfDefined","equalsOrV1","v2","v1","structuralEquals","Array","isArray","Object","getPrototypeOf","prototype","aObj","bObj","keysA","keys","keysB","keysBSet","key","WeakMap","BracketInfo","range","nestingLevel","nestingLevelOfEqualBracketType","isInvalid","BracketPairInfo","openingBracketRange","closingBracketRange","bracketPairNode","openingBracketInfo","openingBracket","bracketInfo","BracketPairWithMinIndentationInfo","minVisibleColumnIndentation","super","BracketPairsTree","didLanguageChange","textModel","getLanguageConfiguration","didChangeEmitter","denseKeyProvider","onDidChange","event","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","tokenization","hasTokens","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","getLanguageId","tokenizer","getValue","handleDidChangeBackgroundTokenizationState","wasUndefined","fire","handleDidChangeTokens","ranges","r","fromLineNumber","toLineNumber","handleEdits","handleContentChanged","change","fromModelContentChanges","changes","tokenChange","combineTextEditInfos","flushQueue","previousAst","immutable","previousAstClone","getBracketsInRange","onlyColorizedBrackets","startLineNumber","startColumn","endLineNumber","endColumn","cb","node","collectBrackets","Map","getBracketPairsInRange","includeMinIndentation","startLength","getStartPosition","endLength","getEndPosition","context","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","position","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","kind","lengths","child","children","level","levelPerBracketType","parentPairIsIncomplete","whileLoop","childCount","childrenLength","getChild","colorize","closingBracket","closesColorized","levelPerBracket","existing","get","set","shouldContinue","openingBracketEnd","minIndentation","computeMinIndentation","curOffset","childOffset","BracketPairsTextModelPart","canBuildAST","getValueLength","languageConfigurationService","bracketPairsTree","_register","onDidChangeEmitter","bracketsRequested","handleLanguageConfigurationServiceChange","e","value","object","clear","updateBracketPairsTree","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","store","disposable","dispose","empty","getBracketPairsInRangeWithMinIndentation","findMatchingBracketUp","_bracket","_position","maxDuration","validatePosition","getLanguageIdAtPosition","column","closingBracketInfo","bracketsNew","getClosingBracketInfo","bracketPair","fromPositions","findLast","closes","bracketsSupport","data","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","filter","item","containsPosition","findLastMaxBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","lineTokens","modeBrackets","tokenIndex","tokenCount","getCount","currentLanguageId","searchStartOffset","tokenEndOffset","getEndOffset","getStandardTokenType","searchEndOffset","getLineContent","tokenStartOffset","getStartOffset","getLineTokens","findTokenIndexAtOffset","currentModeBrackets","bestResult","foundBracket","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","matched","_findMatchingBracketDown","count","totalCallCount","searchPrevMatchingBracketInRange","INSTANCE","hitText","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","lineCount","getLineCount","findPrevBracket","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","strictContainsRange","savedCounts","counts","resetCounts","tmp","searchInRange","getValueInRange","getBracketInfo","startTime","Date","now","_searchCanceledBrand","ColorizedBracketPairsDecorationProvider","colorProvider","ColorProvider","colorizationOptions","getOptions","bracketPairColorizationOptions","bracketPairs","getDecorationsInRange","ownerId","filterOutValidation","onlyMinimapDecorations","enabled","id","description","inlineClassName","getInlineClassName","independentColorPoolPerBracketType","toArray","getAllDecorations","unexpectedClosingBracketClassName","getInlineClassNameOfLevel","theme","collector","colors","addRule","getColor","colorValues","c","isTransparent","color","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","abs","guessIndentation","source","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineText","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","spacesDiffCount","currentLineLength","getLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","lenJ","charCode","getLineCharCode","currentSpacesDiff","insertSpaces","tabSize","tabSizeScore","forEach","possibleTabSize","possibleTabSizeScore","getNodeColor","metadata","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","start","end","parent","left","right","delta","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","reset","versionId","setOptions","className","glyphMarginClassName","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","onlyMarginDecorations","T","intervalStart","intervalEnd","nodeMaxEnd","nodeStart","nodeEnd","include","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","resolveNode","initialNode","acceptReplace","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","x","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","TreeNode","piece","size_left","lf_left","next","righttest","calculateSize","calculateLF","lineFeedCnt","tree","rbDelete","recomputeTreeMetadata","newSizeLeft","newLFLeft","lf_delta","updateTreeMetadata","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","Uint32Array","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","readonly","rLength","chr","Piece","bufferIndex","StringBuffer","buffer","PieceTreeSnapshot","BOM","_pieces","_tree","_BOM","_index","iterate","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","nodePos","nodeStartOffset","get2","nodeStartLineNumber","nodePosition","shift","validate","hasInvalidVal","newArr","entry","PieceTreeBase","chunks","eol","eolNormalized","create","_buffers","_lastChangeBufferPos","line","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","normalizeEOL","averageBufferSize","floor","tempChunk","tempChunkLen","getNodeContent","getEOL","setEOL","newEOL","createSnapshot","getOffsetAt","leftLen","getAccumulatedValue","getPositionAt","lfCnt","originalOffset","out","getIndexOf","remainder","startPosition","nodeAt2","endPosition","getValueInRange2","offsetInBuffer","ret","getLinesContent","lines","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineRawContent","_getCharCode","matchingNode","targetOffset","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","startOffsetInBuffer","searchText","_wordSeparators","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","findMatchesLineByLine","searchRange","wordSeparators","regex","currentNode","lineBreakCnt","nextLineStartOffset","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","lastMatchIndex","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","nodeCharCodeAt","newStart","startWithLF","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","rbInsertLeft","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","nPiece","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","previousCharOffset","cursor","nodes","lastChar","splitText","slice","endIndex","endPos","newPiece","cache","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEndOffset","newLineFeedCnt","size_delta","originalStartOffset","originalStartPos","originalEndPos","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","newOffset","val","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","p","prevNode","PieceTreeTextBuffer","containsRTL","containsUnusualLineTerminators","_onDidChangeContent","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","preserveBOM","getRangeAt","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","eolOffsetCompensation","desiredEOL","actualEOL","getCharacterCountInRange","lineContent","fromOffset","toOffset","strings","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","Error","applyEdits","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","op","_isTracked","validatedRange","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","bufferEOL","sortIndex","identifier","rangeOffset","rangeLength","Boolean","isAutoWhitespaceEdit","_sortOpsAscending","hasTouchingRanges","rangeEnd","nextRangeStart","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","prevContent","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","_sortOpsDescending","delete","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","compareRangesUsingEnds","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_getEOL","defaultEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","acceptChunk","chunk","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","createLineStarts","finish","_finish","lastChunk","newLineStarts","FixedArray","_default","_store","before","after","insertArr","arrayFill","deleteIndex","deleteCount","splice","insertIndex","insertCount","ContiguousMultilineTokens","_startLineNumber","_tokens","tokens","appendLineTokens","ContiguousMultilineTokensBuilder","last","finalize","TokenizerWithStateStore","tokenizationSupport","initialState","getInitialState","TrackingTokenizationStateStore","getStartState","getFirstInvalidLine","TokenizerWithStateStoreAndTextModel","_textModel","_languageIdCodec","updateTokensUntilLine","builder","lineToTokenize","safeTokenize","startState","setEndState","endState","getTokenTypeIfInsertingCharacter","character","lineStartState","tokenizeLineWithEdit","curLineContent","newLineContent","hasAccurateTokensForLine","getFirstInvalidEndStateLineNumberOrMax","isCheapToTokenize","firstInvalidLineNumber","tokenizeHeuristically","heuristicTokens","state","guessStartState","nonWhitespaceColumn","likelyRelevantLines","newNonWhitespaceIndex","_tokenizationStateStore","TokenizationStateStore","_invalidEndStatesLineNumbers","RangePriorityQueueImpl","addRange","getEndState","acceptChange","newLineCount","addRangeAndResize","endLineNumberExclusive","acceptChanges","invalidateEndStateRange","getFirstInvalidEndStateLineNumber","Number","MAX_SAFE_INTEGER","allStatesValid","_lineEndStates","oldState","_ranges","idx","findIndex","contains","endExclusive","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","languageIdCodec","hasEOL","tokenizeEncoded","clone","nullTokenize","encodeLanguageId","convertToEndOffset","DefaultBackgroundTokenizer","_tokenizerWithStateStore","_backgroundTokenStore","_isDisposed","_isScheduled","handleChanges","_beginBackgroundTokenization","isAttachedToEditor","_hasLinesToTokenize","deadline","_backgroundTokenizeWithDeadline","endTime","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","sw","elapsed","_tokenizeOneInvalidLine","setTokens","checkFinished","firstInvalidLine","backgroundTokenizationFinished","requestTokens","AttachedViews","_onDidChangeVisibleRanges","onDidChangeVisibleRanges","_views","attachView","view","AttachedViewImpl","detachView","handleStateChange","setVisibleLines","visibleLines","stabilized","visibleLineRanges","AttachedViewHandler","lineRanges","_lineRanges","_refreshTokens","runner","update","_computedLineRanges","cancel","schedule","AbstractTokens","_backgroundTokenizationState","_onDidChangeBackgroundTokenizationState","onDidChangeBackgroundTokenizationState","_onDidChangeTokens","onDidChangeTokens","tokenizeIfCheap","forceTokenization","TreeSitterTokens","_treeSitterService","_tokenizationSupport","_initialize","newLanguage","_lastLanguageId","content","rawTokens","createEmpty","resetTokenization","fireTokenChangeEvent","semanticTokensApplied","handleDidChangeAttached","isFlush","getParseResult","EMPTY_LINE_TOKENS","ContiguousTokensEditing","deleteBeginning","toChIndex","deleteEnding","fromChIndex","toUint32Array","lineTextLength","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","lastEnd","subarray","append","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","ContiguousTokensStore","_lineTokens","_len","flush","getTokens","topLevelLanguageId","lineIndex","rawLineTokens","getDefaultMetadata","_massageTokens","hasDifferentLanguageId","byteOffset","byteLength","_ensureLine","_deleteLines","_insertLines","arrays","checkEquality","oldTokens","_equals","_a","_b","acceptEdit","_acceptDeleteRange","_acceptInsertText","firstLineIndex","lastLineIndex","lastLineTokens","setMultilineTokens","minChangedLineNumber","maxChangedLineNumber","hasChange","SparseTokensStore","_isComplete","isComplete","setPartial","_range","_firstRange","getRange","_lastRange","plusRange","insertPosition","removeTokens","split","addSparseTokens","aTokens","bTokens","_findFirstPieceWithLine","aLen","bLen","aIndex","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","getMetadata","bMask","aMask","aMergeIndex","firstCharCode","TokenizationTextModelPart_1","__decorate","decorators","target","desc","d","arguments","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","TokenizationTextModelPart","_bracketPairsTextModelPart","_languageId","_attachedViews","_languageService","_languageConfigurationService","_semanticTokens","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_tokensDisposables","affects","changedLanguages","includes","createPreferredTokenProvider","createGrammarTokens","GrammarTokens","createTreeSitterTokens","createTokens","useTreeSitter","needsReset","_emitModelTokensChangedEvent","isEolChange","validateLineNumber","syntacticTokens","_isDisposing","setSemanticTokens","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","validateRange","getWordAtPosition","assertNotDisposed","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getWordDefinition","lbStartOffset","lbEndOffset","leftBiasedWord","getWordUntilPosition","wordAtPosition","word","setLanguageId","oldLanguage","ITreeSitterParserService","attachedViews","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","_debugBackgroundTokenizer","_attachedViewStates","refreshRanges","deleteAndDispose","_debugBackgroundTokens","_debugBackgroundStates","isTooLargeForTokenization","initializeTokenization","firstInvalidEndStateLineNumber","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","refreshAllVisibleLineTokens","joinMany","_","s","refreshRange","changedTokens","backgroundResult","reportMismatchingTokens","validatedPosition","TextModel_1","createTextBuffer","factory","createTextBufferFactory","model","snapshot","createTextBufferFactoryFromSnapshot","MODEL_ID","TextModelSnapshot","_source","_eos","resultCnt","resultLength","invalidFunc","TextModel","_MODEL_SYNC_LIMIT","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","LARGE_FILE_HEAP_OPERATION_THRESHOLD","DEFAULT_CREATION_OPTIONS","isForSimpleWidget","indentSize","detectIndentation","trimAutoWhitespace","largeFileOptimizations","resolveOptions","guessedIndentation","_tokenizationTextModelPart","onDidChangeContent","listener","_eventEmitter","slowEvent","contentChangedEvent","onDidChangeContentOrInjectedText","fastEvent","_onDidChangeInjectedText","__isDisposing","_bracketPairs","guides","_guidesTextModelPart","languageIdOrSelection","creationOptions","associatedResource","_undoRedoService","instantiationService","_onWillDispose","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","_associatedResource","parse","_attachedEditorCount","_buffer","_bufferDisposable","_options","_setLanguage","_decorationProvider","createInstance","bufferLineCount","bufferTextLength","_isTooLargeForTokenization","_isTooLargeForHeapOperation","_isTooLargeForSyncing","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_instanceId","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","endDeferredEmit","requestRichLanguageFeatures","emptyDisposedTextBuffer","None","_assertNotDisposed","_emitContentChangedEvent","rawChange","setValue","_setValueFromTextBuffer","_createContentChanged2","isUndoing","isRedoing","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","getLineMaxColumn","_increaseVersionId","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","onBeforeAttached","onBeforeDetached","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForHeapOperation","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineLength","uri","getFormattingOptions","updateOptions","_newOpts","originalIndentSize","bracketColorizationOptions","newOpts","createChangeEvent","normalizeIndentation","removeUnusualLineTerminators","selections","matches","findMatches","pushEditOperations","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","_validatePosition","rawOffset","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","rawRange","getEndOfLineSequence","getLineMinColumn","_validateRangeRelaxedNoAllocations","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","_lineNumber","_column","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","modifyPosition","candidate","rawSearchScope","isRegex","matchCase","searchRanges","every","searchScope","isIRange","d1","d2","uniqueSearchRanges","matchMapper","reduce","areIntersecting","parseSearchRequest","findNextMatch","rawSearchStart","searchStart","findPreviousMatch","pushStackElement","popStackElement","pushEOL","_validateEditOperation","rawOperation","_validateEditOperations","beforeCursorState","editOperations","cursorStateComputer","_pushEditOperations","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","charAt","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","resultingSelection","rangeStart","_applyUndoRedoEdits","_applyRedo","oldLineCount","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","fromDecorations","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","injectedTexts","newLines","takeWhile","reverseEdits","undo","canUndo","redo","canRedo","size","lineChangeEvents","from","_getInjectedTextInLine","changeDecorations","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","removeAllDecorationsWithOwnerId","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","getLinesDecorations","_endLineNumber","decorations","_getDecorationsInRange","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","t","getAllMarginDecorations","filterRange","getAllInInterval","oldRange","recordLineAffectedByInjectedText","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","nodeIsInOverviewRuler","nodeRange","movedInOverviewRuler","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","setLanguage","normalizePosition","affinity","getLineIndentColumn","indent","indentOfLine","isNodeInOverviewRuler","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","r1","r2","showIfCollapsed","overviewRulerOnly","_search","_resolveNode","cleanClassName","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","Center","type","_resolveColor","invalidateCachedColor","ModelDecorationGlyphMarginOptions","persistLane","ModelDecorationMinimapOptions","sectionHeaderStyle","sectionHeaderText","fromHex","ModelDecorationInjectedTextOptions","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","register","createDynamic","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","lineNumberHoverMessage","isWholeLine","minimap","glyphMargin","linesDecorationsClassName","lineNumberClassName","linesDecorationsTooltip","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","_affectsLineNumber","doFire","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","affectsLineNumber","_fastEmitter","_slowEmitter","_deferredEvent","rawContentChangedEvent","merge","ILanguageFeatureDebounceService","IdentityHash","_hashes","pool","of","obj","NullDebounceInformation","_model","_value","FeatureDebounceInformation","_logService","_name","_registry","_min","_max","_key","all","hashVal","avg","default","newValue","trace","_overall","LanguageFeatureDebounceService","envService","_data","_isDev","isExtensionDevelopment","isBuilt","feature","name","config","extra","info","debug","_overallAverage","values","constObservable","ConstObservable","debugName","addObserver","observer","removeObserver","observableFromEvent","args","owner","FromEventObservable","globalTransaction","observableFromEventOpts","debugReferenceFn","equalsFn","_debugNameData","_getValue","_getTransaction","_equalityComparator","hasValue","handleEvent","oldValue","didChange","didRunTransaction","tx","handleFromEventObservableTriggered","hadValue","o","observers","updateObserver","handleChange","getDebugName","onFirstObserverAdded","subscription","onLastObserverRemoved","observableSignalFromEvent","FromEventObservableSignal","Observer","batchEventsGlobally","fn","didSet","observableSignal","debugNameOrOwner","ObservableSignal","_owner","_debugName","trigger","recomputeInitiallyAndOnChange","observable","handleValue","KeepAliveObserver","reportChanges","_forceRecompute","_handleValue","_counter","beginUpdate","endUpdate","handlePossibleChange","derivedObservableWithCache","computeFn","lastValue","reader","mapObservableArrayCached","items","keySelector","ArrayMap","setItems","getItems","_map","_keySelector","_items","newItems","itemsToRemove","derivedConstOnceDefined","EDITOR_MODEL_DEFAULTS","autorun","AutorunObserver","autorunOpts","autorunHandleChanges","createEmptyChangeSummary","autorunWithStoreHandleChanges","changeSummary","autorunWithStore","_runFn","createChangeSummary","_handleChange","updateCount","disposed","dependencies","dependenciesToBeRemoved","handleAutorunCreated","_runIfNeeded","emptySet","handleAutorunTriggered","handleAutorunFinished","assert","changedObservable","readObservable","ObservablePromise","fromFn","promise","promiseResult","then","PromiseResult","error","waitForState","predicate","isError","cancellationToken","Promise","resolve","reject","isImmediateRun","shouldDispose","stateObs","isFinished","dc","onCancellationRequested","isCancellationRequested","LazyObservableValue","initialValue","_isUpToDate","_deltas","_updateCounter","_update","_beginUpdate","_endUpdate","shouldCallBeginUpdate","shouldCallEndUpdate","_tx","_setValue","observableValueOpts","lazy","derived","computeFnOrOwner","Derived","derivedWithSetter","setter","DerivedWithSetter","derivedOpts","derivedHandleChanges","equalityComparer","derivedWithStore","computeFnOrUndefined","derivedDisposable","_computeFn","_handleLastObserverRemoved","handleDerivedCreated","_recomputeIfNeeded","handleDerivedRecomputed","_observable","propagateBeginUpdate","shouldReact","wasUpToDate","debugNameData","handleLastObserverRemoved","equalityComparator","createScopedLineTokens","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","actual","firstCharOffset","lastCharOffset","_scopedLineTokensBrand","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","getActualLineContentBefore","getTokenCount","toIViewLineTokens","sliceAndInflate","ignoreBracketsInToken","standardTokenType","encodeSemanticTokensDto","semanticTokens","deltas","encodeSemanticTokensDtoSize","uint8Arr","Uint8Array","b0","b1","b2","b3","reverseEndianness","wrap","toLittleEndianBuffer","TextEditInfo","lift","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","TextEditInfoCache","getOffsetBeforeChange","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","columnCount","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","ITreeViewsDnDService","TreeViewsDnDService","MarkerSeverity","IMarkerData","compare","_displayStrings","Warning","Info","fromSeverity","severity","Ignore","Hint","toSeverity","emptyString","makeKeyOptionalMessage","markerData","useMessage","code","message","makeKey","IMarkerService","TextModelPart","Token","bracketId","bracketIds","astNode","TextBufferTokenizer","bracketTokens","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","textBufferLastLineLength","skip","setPosition","token","peek","lineIdx","lineCharOffset","lineTokenOffset","peekedToken","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","isOther","getTokenType","containsBracketType","containsBalancedBrackets","regexp","regExpGlobal","lastIndex","exec","getToken","getEmpty","FastTokenizer","regExpStr","getRegExpStr","RegExp","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","colCount","_recomputeInitiallyAndOnChange","_keepObserved","_derived","_globalTransaction","_setRecomputeInitiallyAndOnChange","_setKeepObserved","keepObserved","_setDerivedOpts","ConvenientObservable","TChange","fnOrOwner","fnOrUndefined","flatten","BaseObservable","transaction","TransactionImpl","async","asyncTransaction","subtransaction","_fn","_getDebugName","updatingObservers","handleBeginTransaction","handleEndTransaction","observableValue","nameOrOwner","ObservableValue","handleObservableChanged","disposableObservableValue","DisposableObservableValue","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","toLength","lengthZero","lengthIsZero","factor","lengthToObj","l","lengthGetLineCount","lengthGetColumnCountIfZeroLineCount","lengthAdd","l1","l2","sumLengths","lengthFn","lengthEquals","length1","length2","lengthDiffNonNegative","lineCount1","lineCount2","colCount2","lengthLessThan","lengthLessThanEqual","lengthGreaterThanEqual","positionToLength","lengthsToRange","lengthStart","lengthEnd","lengthOfString","globalObservableLogger","setLogger","logger","getLogger","ConsoleObservableLogger","indentation","changedObservablesSets","textToConsoleArgs","styles","firstArg","process","style","consoleTextToArgs","normalText","repeat","formatInfo","styled","formatValue","strikeThrough","log","formatKind","formatChanges","existingHandleChange","apply","changedObservables","referenceFn","transactionName","padStr","bold","styleObj","entries","styleString","propName","propValue","availableLen","first","formatArray","formatObject","ITextModelService","SemanticTokensStylingService","_themeService","_caches","onDidColorThemeChange","getStyling","provider","SemanticTokensProviderStyling","getLegend","ISemanticTokensStylingService","IUndoRedoService","ResourceEditStackSnapshot","resource","elements","UndoRedoGroup","_ID","order","nextOrder","UndoRedoSource","ModelService_1","ModelData","_modelEventListeners","DEFAULT_EOL","DisposedModelInfo","initialUndoRedoSnapshot","time","sharesUndoRedoStack","heapSize","sha1","alternativeVersionId","ModelService","MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK","_configurationService","_resourcePropertiesService","_instantiationService","_onModelAdded","onModelAdded","_onModelRemoved","onModelRemoved","_onModelModeChanged","onModelLanguageChanged","_modelCreationOptionsByLanguageAndResource","_models","_disposedModels","_disposedModelsHeapSize","onDidChangeConfiguration","_updateModelOptions","_readModelOptions","editor","parsedTabSize","parseInt","parsedIndentSize","newDefaultEOL","bracketPairColorization","language","overrideIdentifier","_shouldRestoreUndoStack","getCreationOptions","oldOptionsByLanguageAndResource","modelId","modelData","affectsConfiguration","oldOptions","newOptions","_setModelOptionsForModel","currentOptions","_insertDisposedModel","disposedModelData","_removeDisposedModel","_ensureDisposedModelsHeapSize","maxModelsHeapSize","disposedModels","disposedModel","restoreSnapshot","_createModelData","getElements","sha1Computer","_getSHA1Computer","sha1IsEqual","canComputeSHA1","computeSHA1","past","matchesResource","setModel","future","setElementsValidFlag","createModel","languageSelection","getModels","getModel","_schemaShouldMaintainUndoRedoElements","scheme","file","vscodeRemote","vscodeUserData","vscodeNotebookCell","getUriComparisonKey","maintainUndoRedoStack","maxMemory","oldLanguageId","newLanguageId","DefaultModelSHA1Computer","ITextResourcePropertiesService","MAX_MODEL_SIZE","shaComputer","digest","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","toLengthMapping","s1ToS2Map","modified","lengthBefore","lengthAfter","curItem","dequeue","nextS0ToS1MapWithS1LengthOf","s1Length","v","unshift","remainingItem","splitAt","LengthMapping","pushEdit","lastResult","s0offset","s1ToS2","s0Length","s0EndOffset","s1","s0startOffset","remainingLengthAfter","textEditInfos","lastOffset","textEditInfo","spaceLength","IndentAction","StandardAutoClosingPairConditional","_neutralCharacter","_neutralCharacterSearched","_inString","_inComment","_inRegEx","notIn","isOK","standardToken","shouldAutoClose","_findNeutralCharacterInRange","toCharCode","findNeutralCharacter","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","DebugNameData","debugNameSource","cached","cachedDebugName","dbgName","self","ownerStr","ctor","getClassName","countPerClassName","formatOwner","getFunctionName","findKey","computeDebugName","countPerName","fnSrc","trim","computeIndentLevel","chCode","CharacterPairSupport","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS","_autoClosingPairs","el","__electricCharacterSupport","docComment","_autoCloseBeforeForQuotes","autoCloseBefore","_autoCloseBeforeForBrackets","_surroundingPairs","surroundingPairs","getAutoClosingPairs","getAutoCloseBeforeSet","forQuotes","getSurroundingPairs","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","getElectricCharacters","onElectricCharacter","bracketText","textBeforeBracket","matchOpenBracket","resetGlobalRegex","reg","global","IndentRulesSupport","indentationRules","_indentationRules","shouldIncrease","increaseIndentPattern","shouldDecrease","decreaseIndentPattern","shouldIndentNextLine","indentNextLinePattern","shouldIgnore","unIndentedLinePattern","getIndentMetadata","OnEnterSupport","opts","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","onEnter","autoIndent","beforeEnterText","afterEnterText","rule","beforeText","afterText","action","indentAction","IndentOutdent","Indent","_safeRegExp","def","err","LanguageBracketsConfiguration","filterValidBrackets","openingBracketInfos","closing","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","colorizedBracketPairs","_openingBrackets","cachedValues","_closingBrackets","openingBrackets","closingBrackets","getOpeningBracketInfo","getBracketRegExp","BracketKindBase","openedBrackets","isOpeningBracket","openingColorizedBrackets","other","getOpeningBrackets","LanguageConfigurationServiceChangeEvent","ILanguageConfigurationService","LanguageConfigurationService","configurationService","languageService","LanguageConfigurationRegistry","configurations","languageConfigKeys","customizedLanguageConfigKeys","globalConfigChanged","some","localConfigChanged","overrides","overrideLangName","isRegisteredLanguageId","configuration","priority","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","validateBracketPairs","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","computeConfig","getIndentationAtPosition","ComposedLanguageConfiguration","_resolved","_entries","_order","LanguageConfigurationContribution","getResolvedConfiguration","_resolve","cmp","configs","comments","wordPattern","folding","LanguageConfigurationChangeEvent","_onDidChange","offSide","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","indentRulesSupport","foldingRules","electricCharacter","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","GuidesTextModelPart","_computeIndentLevel","getActiveIndentGuide","minLineNumber","maxLineNumber","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","includeSingleLinePairs","activeBracketPairRange","bracketsContainingActivePosition","bp","strictContainsPosition","BracketPairGuidesClassNames","isActive","equalsRange","includeInactive","highlightActive","activeClassName","horizontalGuides","Enabled","EnabledForActive","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","visibleColumn","visibleColumnFromColumn","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","uriGetComparisonKey","SingleModelEditStackData","getModelEOL","beforeVersionId","afterVersionId","beforeEOL","afterEOL","afterCursorState","textChanges","_writeSelectionsSize","_writeSelections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_readSelections","serialize","necessarySize","deserialize","changeCount","SingleModelEditStackElement","isUri","label","canAppend","MultiModelEditStackElement","resources","_editStackElementsArr","editStackElement","editStackElements","_isOpen","_editStackElementsMap","_delegate","prepareUndoRedo","isEditStackElement","EditStack","undoRedoService","lastElement","getLastElement","removeElements","_getOrCreateEditStackElement","newElement","pushElement","inverseEditOperations","_computeCursorState","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","decodeUTF16LE","compatDecodeUTF16LE","StringBuilder","capacity","_capacity","_completedStrings","_bufferLength","build","_flushBuffer","_buildBuffer","bufferString","appendCharCode","remainingSpace","appendASCIICharCode","appendString","strLen","LineTokens","defaultTokenMetadata","decoder","defaultMetadata","createFromTextAndMetadata","fullText","_lineTokensBrand","_tokensCount","_text","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","decodeLanguageId","getForeground","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getPresentation","getPresentationFromMetadata","inflate","SliceLineTokens","desiredIndex","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","nextOriginalTokenEndOffset","nextInsertToken","getTokenText","_startOffset","_endOffset","_deltaOffset","adjustedTokenIndex","getStandardTokenTypeAtPosition","firstNonWhitespaceIndex","spacesCnt","nextIndentTabStop","tabsCnt","_normalizeIndentationFromWhitespace","ThemeColor","ThemeIcon","isThemeColor","iconNameSegment","iconNameExpression","iconModifierExpression","iconNameCharacter","ThemeIconIdRegex","asClassNameArray","icon","modifier","classNames","asClassName","asCSSSelector","isThemeIcon","_regexFromString","fromString","fromId","modify","tildeIndex","lastIndexOf","getModifier","isEqual","ti1","ti2","emptyArr","SmallImmutableSet","additionalItems","keyProvider","getKey","newItem","item1","item2","intersects","identityKeyProvider","DenseKeyProvider","HorizontalGuidesState","IndentGuide","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","IndentGuideHorizontalLine","top","CursorColumns","_nextVisibleColumn","codePoint","nextRenderTabStop","textLen","iterator","nextGraphemeLength","columnFromVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","prevRenderTabStop","prevIndentTabStop","clamp","MovingAverage","_n","_val","SlidingWindowAverage","_values","_sum","fill","BaseAstNode","PairAstNode","missingOpeningBracketIds","listHeight","canBeReused","openBracketIds","deepClone","ListAstNode","create23","item3","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","makeLastElementMutable","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","handleChildrenChanged","unopenedBrackets","_item3","_item1","_item2","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","_children","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","firstNonWsColumn","BracketAstNode","InvalidBracketAstNode","openedBracketIds","Severity","_error","_warning","_info","fromValue","registerSingleton","ctorOrDescriptor","supportsDelayedInstantiation","getSingletonServiceDescriptors","concat23TreesOfSameHeight","createImmutableLists","heightDiff","node1","node2","list","nodeToAppend","curNode","parents","nodeToAppendOfCorrectHeight","nodeToPrependOfCorrectHeight","prepend","NodeReader","nextNodes","offsets","idxs","readLongestNodeAt","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","curIdx","parseDocument","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","tryReadChildFromCache","parseChild","readNode","height","second","concat23Trees","maxCacheableLength","cachedNode","nextToken","score","selector","candidateUri","candidateLanguage","candidateIsSynchronized","candidateNotebookUri","candidateNotebookType","pattern","hasAccessToAllModels","notebookType","normalizedPattern","base","fsPath","fileIconDirectoryRegex","getIconClasses","modelService","fileKind","classes","ROOT_FOLDER","FOLDER","parseMetaData","META_DATA_LABEL","path","cssEscape","authority","dotSegments","detectedLanguageId","mime","META_DATA_MIME","getLanguageIdByMimeType","guessLanguageIdByFilepathOrFirstLine","detectLanguageId","IMarkerDecorationsService","isExclusive","exclusive","MatchCandidate","notebookUri","recursive","LanguageFeatureRegistry","_notebookInfoResolver","_clock","_score","_time","_lastCandidate","_updateScores","ordered","_orderedForEach","orderedGroups","lastBucket","lastBucketScore","notebookInfo","_compareByScoreAndTime","isBuiltinSelector","isBuiltin","LanguageFeaturesService","referenceProvider","bind","renameProvider","newSymbolNamesProvider","codeActionProvider","definitionProvider","typeDefinitionProvider","declarationProvider","implementationProvider","documentSymbolProvider","inlayHintsProvider","codeLensProvider","documentFormattingEditProvider","documentRangeFormattingEditProvider","onTypeFormattingEditProvider","signatureHelpProvider","hoverProvider","documentHighlightProvider","multiDocumentHighlightProvider","selectionRangeProvider","foldingRangeProvider","linkProvider","inlineCompletionsProvider","inlineEditProvider","completionProvider","linkedEditingRangeProvider","documentRangeSemanticTokensProvider","documentSemanticTokensProvider","documentDropEditProvider","documentPasteEditProvider","_notebookTypeResolver","ILanguageFeaturesService","SyncDescriptor","staticArguments","ModelRawFlush","changeType","LineInjectedText","applyInjectedText","lastOriginalOffset","injectedText","decoration","ModelRawLineChanged","detail","ModelRawLinesDeleted","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","containsEvent","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","_mergeChangeEvents","LanguageService","instanceCount","warnOnOverwrite","_onDidRequestBasicLanguageFeatures","onDidRequestBasicLanguageFeatures","_onDidRequestRichLanguageFeatures","onDidRequestRichLanguageFeatures","leakWarningThreshold","_requestedBasicLanguages","_requestedRichLanguages","LanguagesRegistry","getLanguageIdByLanguageName","languageName","mimeType","firstLine","languageIds","createById","LanguageSelection","_createAndGetLanguageIdentifier","createByFilepathOrFirstLine","requestBasicLanguageFeatures","getOrCreate","onDidChangeLanguages","fromObservable","BracketTokens","createFromLanguage","getId","openingTextId","hasRegExp","_regExpGlobal","escaped","findClosingTokenText","openingBracketIds","closingText","LanguageAgnosticBracketTokens","languageIdToBracketTokens","singleLanguageBracketTokens","IEnvironmentService","diffSets","removed","added","intersection","setA","setB","elem","FileKind","MarkerDecorationsService","_markerService","_onDidChangeMarker","_markerDecorations","onMarkerChanged","_handleMarkerChange","getMarker","markerDecorations","changedResources","_updateDecorations","MarkerDecorations","inMemory","internal","vscode","marker","remove","markers","take","IModelService","oldIds","_createDecorationRange","_createDecorationOption","ids","removedMarker","rawMarker","_hasMarkerTag","setEndPosition","MAX_VALUE","minColumn","tags","Right","tag","IEditorWorkerService","NullState","nullTokenizeEncoded"],"sourceRoot":""}